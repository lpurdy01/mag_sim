#!/usr/bin/env python3
"""Top-down visualisation of the validation wire magnetic field.

This helper reads the ``outputs/validation_wire_field.csv`` artifact produced by
``analytic_wire_test`` and renders both the magnetic flux density magnitude and
its direction in the XY plane. Use it after running the C++ test::

    cmake --build build -j
    ctest --test-dir build --output-on-failure -R analytic_wire
    python python/visualize_wire_field.py

The output window overlays a quiver plot on top of a colour map so you can
inspect the circular field pattern and confirm that the arrows follow the
expected azimuthal direction around the central wire.
"""

from __future__ import annotations

import argparse
import csv
import pathlib
from typing import Tuple

import matplotlib.pyplot as plt
import numpy as np


def load_field_csv(path: pathlib.Path) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Load flattened grid arrays from the CSV file."""

    xs = []
    ys = []
    bxs = []
    bys = []
    bmags = []

    with path.open("r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            xs.append(float(row["x"]))
            ys.append(float(row["y"]))
            bxs.append(float(row["Bx"]))
            bys.append(float(row["By"]))
            bmags.append(float(row["Bmag"]))

    return (
        np.asarray(xs),
        np.asarray(ys),
        np.asarray(bxs),
        np.asarray(bys),
        np.asarray(bmags),
    )


def reshape_grid(xs: np.ndarray, ys: np.ndarray, values: Tuple[np.ndarray, ...]) -> Tuple[np.ndarray, np.ndarray, Tuple[np.ndarray, ...]]:
    """Reshape flattened vectors into 2-D arrays."""

    unique_x = np.unique(xs)
    unique_y = np.unique(ys)
    nx = unique_x.size
    ny = unique_y.size

    if xs.size != nx * ny:
        raise ValueError("Unexpected CSV size; cannot reshape into regular grid")

    order = np.argsort(ys, kind="mergesort")  # stable so x-order is preserved per row
    xs = xs[order]
    ys = ys[order]
    reshaped_values = []
    for arr in values:
        reshaped_values.append(arr[order].reshape(ny, nx))

    grid_x = xs.reshape(ny, nx)
    grid_y = ys.reshape(ny, nx)
    return grid_x, grid_y, tuple(reshaped_values)


def plot_field(
    grid_x: np.ndarray,
    grid_y: np.ndarray,
    bx: np.ndarray,
    by: np.ndarray,
    bmag: np.ndarray,
    rc: float,
    skip: int,
    save: pathlib.Path | None,
) -> None:
    """Render the magnetic field magnitude and direction."""

    fig, ax = plt.subplots(figsize=(6, 5))
    pcm = ax.pcolormesh(
        grid_x,
        grid_y,
        bmag,
        shading="auto",
        cmap="viridis",
    )
    fig.colorbar(pcm, ax=ax, label="|B| [T]")

    ax.quiver(
        grid_x[::skip, ::skip],
        grid_y[::skip, ::skip],
        bx[::skip, ::skip],
        by[::skip, ::skip],
        color="w",
        scale=0.002,
        width=0.003,
        pivot="mid",
    )

    circle = plt.Circle((0.0, 0.0), rc, color="red", fill=False, linestyle="--", linewidth=1.5)
    ax.add_patch(circle)
    ax.text(0.0, rc + 0.002, "wire radius", color="red", ha="center", va="bottom")

    ax.set_aspect("equal", adjustable="box")
    ax.set_xlabel("x [m]")
    ax.set_ylabel("y [m]")
    ax.set_title("Magnetic flux density around the validation wire")
    ax.set_xlim(grid_x.min(), grid_x.max())
    ax.set_ylim(grid_y.min(), grid_y.max())
    ax.grid(False)

    if save is not None:
        fig.savefig(save, dpi=200, bbox_inches="tight")
        print(f"Saved figure to {save}")

    plt.show()


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--csv",
        type=pathlib.Path,
        default=pathlib.Path("outputs/validation_wire_field.csv"),
        help="Path to the CSV field map generated by the C++ test.",
    )
    parser.add_argument(
        "--core-radius",
        type=float,
        default=None,
        help="Wire core radius [m]; defaults to 3*dx inferred from the grid spacing.",
    )
    parser.add_argument(
        "--quiver-skip",
        type=int,
        default=4,
        help="Plot every Nth vector to keep the quiver readable.",
    )
    parser.add_argument(
        "--save",
        type=pathlib.Path,
        default=None,
        help="Optional output path for saving the rendered figure.",
    )
    args = parser.parse_args()

    if not args.csv.exists():
        raise SystemExit(f"CSV file not found: {args.csv} â€” run analytic_wire_test first.")

    xs, ys, bxs, bys, bmags = load_field_csv(args.csv)
    grid_x, grid_y, (bx, by, bmag) = reshape_grid(xs, ys, (bxs, bys, bmags))

    dx = np.min(np.abs(np.diff(np.unique(grid_x[0, :])))) if grid_x.shape[1] > 1 else 0.0
    rc = args.core_radius if args.core_radius is not None else 3.0 * dx

    plot_field(grid_x, grid_y, bx, by, bmag, rc, max(1, args.quiver_skip), args.save)


if __name__ == "__main__":
    main()
