{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mag_sim Docs","text":"<p>Navigate via the User Guide to run and visualize simulations, the Developer Guide to dive into solver internals, and Reference for equations, CLI flags, and file formats.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Follow these steps to build the solver, generate a bundled scenario, and inspect the resulting fields.</p>"},{"location":"quickstart/#1-build-the-project","title":"1. Build the project","text":"<pre><code>cmake -S . -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j\n</code></pre>"},{"location":"quickstart/#2-generate-a-scenario","title":"2. Generate a scenario","text":"<p>The repository ships a generator for the three-phase stator demo:</p> <pre><code>python3 python/gen_three_phase_stator.py --profile ci --out inputs/three_phase_stator_ci.json\n</code></pre>"},{"location":"quickstart/#3-solve-the-field","title":"3. Solve the field","text":"<pre><code>./build/motor_sim --scenario inputs/three_phase_stator_ci.json --solve --vtk-series outputs/three_phase_ci.pvd\n</code></pre> <p>Use <code>--parallel-frames</code> to solve timeline frames concurrently and <code>--warm-start</code> to reuse the previous solution when stepping through the series.</p>"},{"location":"quickstart/#4-visualize-the-results","title":"4. Visualize the results","text":"<p>Open the emitted <code>.pvd</code> time series in ParaView or your preferred VTK viewer. See Visualization Overview for guidance and the VTK Output reference for file structure details.</p>"},{"location":"developer-guide/dev-environment/","title":"Developer Environment &amp; VS Code Workflow","text":"<p>This guide captures the day-to-day tooling expected for contributors. It assumes GitHub Codespaces, VS Code Remote (WSL/SSH), or a local Linux workstation with CMake \u2265 3.16 and GCC \u2265 11.</p>"},{"location":"developer-guide/dev-environment/#1-command-line-quickstart","title":"1. Command-line quickstart","text":"<pre><code>scripts/setup_env.sh           # optional helper for Codespaces/WSL\ncmake -S . -B build -DCMAKE_BUILD_TYPE=Debug\ncmake --build build -j\nctest --test-dir build --output-on-failure\n</code></pre> <p>Always close the loop with <code>scripts/run_ci_checks.sh</code> before publishing a branch. It rebuilds, runs the full CTest suite in parallel, executes every regression harness, and mirrors the GitHub Actions workflow (scenario solves, ParaView-friendly exports, GIF renders, and CSV collection). A green run here is the fastest way to confirm the hosted CI will pass.</p> <p>The build directory is never committed (<code>.gitignore</code> keeps it clean). Tests live under <code>tests/</code> and are surfaced through CTest so they can be executed both from the terminal and IDE integrations.</p>"},{"location":"developer-guide/dev-environment/#11-iteration-friendly-test-cadence","title":"1.1 Iteration-friendly test cadence","text":"<p>For day-to-day work, favour the smallest slice of the suite that exercises your changes before falling back to the full battery:</p> <ul> <li>Use <code>ctest --output-on-failure -R &lt;regex&gt;</code> (or invoke an individual binary   such as <code>./build/torque_validation_test</code>) while iterating on a specific   feature. This keeps turnaround low and mirrors the CI harness.</li> <li>When touching the solver or scenario ingestion, rerun the relevant timeline   with <code>./build/motor_sim ...</code> to double-check CSV/VTK outputs without waiting   for unrelated regressions.</li> <li>Before publishing a branch or opening a PR, always follow up with   <code>ctest --output-on-failure --parallel $(nproc)</code> (or   <code>scripts/run_ci_checks.sh</code>) so the code you push matches the CI matrix.</li> </ul> <p><code>ctest --parallel</code> honours the <code>CTEST_PARALLEL_LEVEL</code> environment variable; the CI helper script defaults it to <code>$(nproc)</code> so local runs use all available hardware. Set it explicitly (e.g. <code>CTEST_PARALLEL_LEVEL=4</code>) if you need to reserve cores for other tasks.</p>"},{"location":"developer-guide/dev-environment/#12-github-ci-parity","title":"1.2 GitHub CI parity","text":"<p>Unit tests alone are not enough when preparing a change. The GitHub Actions workflow exercises additional scenario solves, renders, and artifact collections. Always finish a feature branch by running <code>scripts/run_ci_checks.sh</code> from the repository root. The helper mirrors <code>.github/workflows/ci.yml</code>, so the results should match what the cloud CI will execute (VTK exports, animation renders, CSV copies, etc.). When the script passes locally you can be confident that the PR will produce the same artefacts as the hosted runner.</p> <p>Key runtime flags for <code>motor_sim</code>:</p> <ul> <li><code>--solver {sor|cg}</code> toggles between the legacy Gauss\u2013Seidel solver and the new preconditioned conjugate gradient (default is   SOR for continuity).</li> <li><code>--pc {none|jacobi|ssor}</code> selects the preconditioner used by CG. Jacobi is a solid first step on lightly conductive grids,   while SSOR accelerates highly anisotropic problems.</li> <li><code>--warm-start</code> reuses the previous frame's field as the initial guess when traversing a timeline, dramatically cutting CG   iterations.</li> <li><code>--use-prolongation</code> seeds the fine-grid solve from an automatically selected coarse solve; adjust with <code>--coarse-nx/--coarse-ny</code>.</li> <li><code>--progress-every &lt;seconds&gt;</code> controls the live progress cadence (default 2 s). Set it to <code>0</code> to emit a sample every iteration   when collecting detailed residual histories.</li> <li><code>--snapshot-every &lt;iters&gt;</code> enables downsampled field dumps requested by progress sinks (handy for spotting spatial stagnation).</li> <li><code>--progress-history &lt;path&gt;</code> writes the emitted residual samples to a CSV. Timeline runs append <code>_frame_###</code> to the basename;   combine with <code>--progress-every 0</code> for a full per-iteration log.</li> <li><code>--quiet</code> suppresses progress output when scripting multiple runs.</li> </ul>"},{"location":"developer-guide/dev-environment/#13-documentation-builds-and-preview","title":"1.3 Documentation builds and preview","text":"<p>The MkDocs site mirrors the repository layout under <code>docs/</code>. Run <code>scripts/build_docs.sh</code> to install the documentation dependencies and execute <code>mkdocs build --strict</code>, matching the CI workflow. Reuse the same command with <code>--skip-install</code> once a virtual environment already contains the requirements. For a live preview during edits, launch <code>mkdocs serve</code> from the repository root and open the reported <code>http://127.0.0.1:8000/</code> URL in a browser; the server reloads automatically when files change.</p>"},{"location":"developer-guide/dev-environment/#2-vs-code-configuration","title":"2. VS Code configuration","text":"<p>The repo ships with <code>.vscode/</code> settings tuned for the <code>CMake Tools</code> and <code>C/C++</code> extensions.</p>"},{"location":"developer-guide/dev-environment/#21-tasks","title":"2.1 Tasks","text":"<p>Use <code>Terminal \u2192 Run Task</code> (or the command palette) to access the predefined tasks:</p> Task label Purpose <code>cmake-configure</code> Configure the out-of-source build directory in Debug mode. <code>cmake-build</code> Build all targets; depends on configuration. <code>ctest</code> Run the full test suite with verbose failure output. <code>run-analytic-wire-test</code> Compile + launch the analytic validation binary in place. <code>run-solver-benchmark</code> Compile + execute the benchmark helper with a lean 129\u00d7129 grid preset. <code>run-two-wire-scenario</code> Build + execute <code>motor_sim</code> against the bundled JSON scenario. <p>These tasks chain automatically (for example, running the benchmark will trigger a build if required). Feel free to duplicate them locally for custom grids or release builds.</p>"},{"location":"developer-guide/dev-environment/#22-debugging","title":"2.2 Debugging","text":"<p>The <code>Run and Debug</code> panel exposes launch configurations for four executables:</p> <ol> <li>motor_sim \u2014 loads JSON scenarios; defaults to printing usage when no args are supplied.</li> <li>Run two-wire scenario \u2014 launches <code>motor_sim</code> with the bundled cancellation case and writes the midline CSV.</li> <li>analytic_wire_test \u2014 deterministic regression for the single-wire case.</li> <li>solver_benchmark \u2014 convenience harness for measuring throughput.</li> </ol> <p>All launchers invoke the <code>cmake-build</code> task beforehand to guarantee the binary is up to date. Adjust command-line arguments via the <code>args</code> array in <code>.vscode/launch.json</code> if you need alternative solver tolerances or grids.</p>"},{"location":"developer-guide/dev-environment/#23-intellisense-hints","title":"2.3 IntelliSense hints","text":"<ul> <li>Compiler path defaults to <code>/usr/bin/g++</code> (set in <code>.vscode/settings.json</code>).</li> <li><code>compile_commands.json</code> is generated automatically inside <code>build/</code> by CMake;   the C/C++ extension will pick it up to power IntelliSense if you add the build   directory to VS Code's workspace settings (the default setup already does this   via the CMake Tools extension).</li> </ul>"},{"location":"developer-guide/dev-environment/#3-codespaces-resource-guidance","title":"3. Codespaces resource guidance","text":"<p>Codespaces typically provide 2 vCPUs and 4 GB RAM on the basic tier. To keep turnaround snappy:</p> <ul> <li>Prefer grid sizes \u2264 257\u00b2 for exploratory runs. Larger domains converge but can   exceed a minute when <code>tol = 1e-6</code>.</li> <li>Disable verbose logging (<code>SolveOptions::verbose = false</code>) unless debugging   convergence, as streaming residuals slows execution considerably.</li> <li>Run <code>solver_benchmark</code> (see Section 4) before committing new solver tweaks to   record performance numbers for regressions.</li> </ul>"},{"location":"developer-guide/dev-environment/#4-solver-benchmarking-toolkit","title":"4. Solver benchmarking toolkit","text":"<p><code>build/solver_benchmark</code> exercises the same setup as the analytic regression but allows custom grid resolutions, tolerances, and repetition counts. Example:</p> <pre><code>./build/solver_benchmark --nx 129 --ny 129 --max-iters 5000 --tol 1e-6 --repeats 5\n</code></pre> <p>The tool reports:</p> <ul> <li>convergence outcome and residual,</li> <li>average/min/max wall-clock time,</li> <li>throughput expressed as millions of cell-iterations per second,</li> <li>milliseconds per million cell-iterations (handy for quick mental estimates).</li> </ul> <p>Add <code>--csv outputs/solver_benchmarks.csv</code> to append results for later plotting or diffing. The CSV header is written automatically the first time.</p>"},{"location":"developer-guide/dev-environment/#5-updating-documentation-with-new-metrics","title":"5. Updating documentation with new metrics","text":"<p>When solver changes land, re-run the benchmark on representative grids (e.g., 129\u00b2 and 257\u00b2) and update <code>docs/solver_performance.md</code> with the new numbers. Include the machine profile (Codespaces, local workstation, etc.) so future contributors can compare apples to apples.</p>"},{"location":"developer-guide/dev-environment/#6-visualisation-helpers","title":"6. Visualisation helpers","text":"<p>The regression test and scenario runner emit optional CSV artefacts under <code>outputs/</code> when they finish. Three Python scripts consume them:</p> <ul> <li><code>python/visualize_wire.py</code> compares the centreline magnitude against the   analytic solution for a finite-radius wire. The dip to zero at the origin is a   physical consequence of the uniform current distribution inside the conductor.</li> <li><code>python/visualize_wire_field.py</code> renders a top-down map with quiver arrows so   you can verify the azimuthal direction of B around the wire.</li> <li><code>python/examples/two_wire_cancel.py</code> writes <code>inputs/two_wire_cancel.json</code> using   the lightweight scenario DSL. Regenerate it if you tweak parameters during   debugging.</li> </ul>"},{"location":"developer-guide/dev-environment/#7-other-ides","title":"7. Other IDEs","text":"<p>CLion, Qt Creator, or bare-terminal workflows operate via the same CMake entry points. The only project-specific requirement is that headers under <code>include/</code> remain on the compiler include path. The <code>scripts/setup_env.sh</code> helper installs the minimal toolchain on Debian/Ubuntu-based systems if you need a quick start.</p>"},{"location":"developer-guide/implementation/flask-gui-progress/","title":"Flask GUI Implementation Progress","text":"<p>This log tracks the development of the Flask-based web prototype for <code>mag_sim</code>. It complements the existing implementation status and progress notes by focusing on the GUI-specific milestones.</p>"},{"location":"developer-guide/implementation/flask-gui-progress/#completed-work","title":"Completed work","text":"<ul> <li>Provisioned the devcontainer with Flask, Flask-CORS, NumPy, Matplotlib, and   <code>ezdxf</code> so the GUI can reuse plotting or DXF parsing helpers when they become   available.</li> <li>Established a Flask application (<code>python/gui/app_flask.py</code>) with:</li> <li>A background <code>SimulationManager</code> that keeps the <code>motor_sim</code> subprocess     isolated from request threads and streams stdout via server-sent events.</li> <li>Upload handling for scenario JSON files with validation and command-line     flag mapping for solver, tolerance, max iterations, and optional outputs.</li> <li>Download endpoints for the uploaded scenario and live log artefacts.</li> <li>Added Bootstrap-backed templates that expose upload controls, progress bar,   log viewer, and download list with minimal JavaScript (EventSource + DOM   updates only).</li> <li>Wrote unit tests that exercise upload flow, stop signalling, and the SSE   endpoint payloads without invoking the real solver binary.</li> <li>Documented usage (<code>docs/user-guide/gui_flask.md</code>) and linked the new page into   the MkDocs navigation.</li> </ul>"},{"location":"developer-guide/implementation/flask-gui-progress/#in-flight-next-steps","title":"In-flight / next steps","text":"<ul> <li>DXF ingestion is still stubbed. Once the geometry-to-scenario converter is   ready we can replace the placeholder guard in <code>/upload</code> with real processing.</li> <li>The progress parser currently looks for percentage tokens in stdout; refining   this to understand the solver's exact log format will improve the progress bar   fidelity.</li> <li>Consider persisting additional solver outputs (e.g., field map CSVs) to the   downloads list once the CLI contract is finalised.</li> <li>Harden long-running process management for multiple users (per-session queues   instead of global state) if the GUI graduates beyond a single-user demo.</li> </ul>"},{"location":"developer-guide/implementation/progress/","title":"Solver Epic Implementation Progress","text":"<p>This log tracks completion of the 10-step plan for the CG solver stack. The entries below summarise the final state after the latest round of work.</p>"},{"location":"developer-guide/implementation/progress/#step-checklist","title":"Step Checklist","text":"<ul> <li>[x] Step 0 \u2013 Goals clarification and acceptance criteria alignment</li> <li>[x] Step 1 \u2013 Confirm math/operator baselines</li> <li>[x] Step 2 \u2013 Update solver APIs and core implementations</li> <li>[x] Step 3 \u2013 Extend CLI/JSON configuration pathways</li> <li>[x] Step 4 \u2013 Expand and parameterise automated tests</li> <li>[x] Step 5 \u2013 Update CI workflow expectations</li> <li>[x] Step 6 \u2013 Ensure implementation follows performance guidelines</li> <li>[x] Step 7 \u2013 Implement live progress formatting</li> <li>[x] Step 8 \u2013 Harden failure handling and guardrails</li> <li>[x] Step 9 \u2013 Refresh documentation</li> <li>[x] Step 10 \u2013 Final acceptance checklist verification</li> </ul>"},{"location":"developer-guide/implementation/progress/#notes","title":"Notes","text":"<ul> <li>Rebased the solver core on a unified <code>solveAz</code> entry point with matrix-free PCG and Jacobi preconditioning, retaining SOR as the reference path.</li> <li>Added Neumann handling helpers (<code>removeMeanIfNeumann</code>, <code>enforceNeumannGauge</code>) and introduced an automatic SOR fallback for pure-Neumann cases to keep CG parity with legacy behaviour.</li> <li>Wired warm-start initial guesses through a light SOR pre-smoothing pass and injected a safety reset when the supplied guess worsens the residual.</li> <li>Implemented coarse-to-fine prolongation support and ensured prolongated guesses are normalised for Neumann grids.</li> <li>Expanded CLI/ingest plumbing for solver selection, warm start, prolongation, progress, quiet mode, and snapshot cadence.</li> <li>Rebuilt the automated test matrix to exercise both solvers, added warm-start/prolongation/progress fixtures, and relaxed iteration-ratio checks to reflect empirical convergence while still enforcing improvement.</li> <li>Updated documentation and AGENT guidance to describe the CG path, warm-start workflow, prolongation hooks, and live progress controls.</li> <li>Verified the full test suite (<code>ctest --output-on-failure</code>) passes with the CG stack enabled and artefact scaffolding intact.</li> <li>Added a <code>solver_visualization_capture</code> utility plus a Python animation pipeline to illustrate warm starts and progress   snapshots for documentation-ready artefact generation.</li> </ul>"},{"location":"developer-guide/implementation/solver-benchmarks/","title":"Solver Performance &amp; Complexity Notes","text":"<p>This note captures rule-of-thumb complexity estimates for the Gauss\u2013Seidel/SOR and conjugate-gradient (CG) solvers, together with timing measurements gathered with <code>tools/solver_benchmark</code>. All reported numbers come from single-threaded runs so you can scale them directly with per-core performance when planning work in lightweight environments such as GitHub Codespaces.</p> <p>The newly introduced harmonic solve (<code>--solver harmonic</code>) reuses the CG backend on a doubled system (real/imaginary components). Complexity follows the CG trends quoted below; expect roughly a 2\u00d7 increase in per-iteration cost versus a purely real solve because the normal equations require two operator applications per iteration.</p>"},{"location":"developer-guide/implementation/solver-benchmarks/#1-complexity-heuristics","title":"1. Complexity heuristics","text":"<ul> <li>Each SOR sweep visits every interior cell once, so the cost per iteration is   \\(\\mathcal{O}(n_x n_y)\\).</li> <li>The number of iterations required to hit a fixed tolerance grows roughly with   the grid dimension because Gauss\u2013Seidel damps high-frequency error quickly but   converges slowly on low-frequency modes. For uniform grids, iteration counts on   the wire test scale approximately with \\(\\mathcal{O}(n_x)\\).</li> <li>Wall-clock time is therefore well-approximated by</li> </ul> <p>$$   t \\approx \\alpha\\, n_x n_y N_\\text{iter},   $$</p> <p>where \\(\\alpha\\) is the time per cell-iteration. On the single-threaded   reference hardware below \\(\\alpha \\approx 9.4 \\times 10^{-8}\\) s (\u2248 94 ms per   million cell-iterations).</p> <p>Measured CG solves follow an \\(\\mathcal{O}(n_x^3)\\) trend while SOR sits close to \\(\\mathcal{O}(n_x^4)\\); see Section\u00a02.3 for the fit parameters.</p> <p>When planning new tests, estimate the runtime via the reported \"ms per million cell-iterations\" (Section 2) or the scaling fits. For example, the CG baseline predicts a 401\u00d7401 solve at <code>1.8e-7 \u00d7 401^3 \u2248 12 s</code>; the SOR solver would require minutes for the same grid because of its steeper \\(\\mathcal{O}(n_x^4)\\) behaviour.</p>"},{"location":"developer-guide/implementation/solver-benchmarks/#2-reference-timings-single-thread-baseline","title":"2. Reference timings (single-thread baseline)","text":"<p>Hardware/software snapshot:</p> <ul> <li>GitHub Codespaces container (Intel Xeon-class core; solver runs on one thread).</li> <li>Ubuntu 22.04 container with GCC 13.3, CMake 3.22.</li> <li>Build type: <code>Debug</code> (default <code>cmake-configure</code>).</li> <li>SIMD hints: enabled by default via the <code>MOTORSIM_ENABLE_SIMD_HINTS</code> CMake option   (adds <code>-DMOTORSIM_SIMD_HINTS</code>). Disable the hints with   <code>-DMOTORSIM_ENABLE_SIMD_HINTS=OFF</code> when comparing against historical runs.</li> <li>Benchmarks executed via <code>tools/solver_benchmark --repeats 3</code>.</li> </ul>"},{"location":"developer-guide/implementation/solver-benchmarks/#21-convergence-comparison","title":"2.1 Convergence comparison","text":"<p>The overlay highlights how quickly the CG backend suppresses low-frequency error compared with SOR on the iron-ring + magnet scenario. Both runs use the same tolerance (1e-6) and operate entirely on a single CPU core.</p>"},{"location":"developer-guide/implementation/solver-benchmarks/#22-field-evolution-snapshots","title":"2.2 Field evolution snapshots","text":"<p>The animated field map (CG trace shown; an SOR variant lives at <code>../../assets/images/progress_snapshots_sor.gif</code>) illustrates which spatial structures are responsible for the final residual plateau. These snapshots are handy when explaining solver behaviour or validating new preconditioners.</p>"},{"location":"developer-guide/implementation/solver-benchmarks/#23-single-thread-scaling-measurements","title":"2.3 Single-thread scaling measurements","text":"<p>The plot combines per-solve timings for grids from 65\u00b2 up to 961\u00b2 (CG) and 65\u00b2\u2013129\u00b2 (SOR). The straight lines show least-squares fits of the form <code>solve_time \u2248 a \u00b7 N^k</code>; coefficients are recorded in <code>docs/solver_benchmark/benchmark/solver_scaling_summary.txt</code>:</p> <ul> <li>CG: \\(k = 2.99,\\ a = 1.82 \\times 10^{-7}\\) seconds.</li> <li>SOR: \\(k = 4.05,\\ a = 1.07 \\times 10^{-8}\\) seconds (fit based on three   points; expect higher variance on larger grids).</li> </ul> <p>Representative samples (single solve, tolerance <code>1e-6</code>, no warm start):</p> Solver Grid N Cells Iterations Avg solve [ms] ~Seconds per 120-frame cycle CG 65 4,225 106 42.3 5.1 CG 129 16,641 213 333.7 40.0 CG 257 66,049 424 2,647.1 317.7 CG 513 263,169 842 20,976.1 2,517.1 (~42 min) CG 961 923,521 1,568 136,917.0 16,430.0 (~4.6 h) Solver Grid N Cells Iterations Avg solve [ms] ~Seconds per 120-frame cycle SOR 65 4,225 624 232.4 27.9 SOR 97 9,409 1,394 1,185.2 142.2 SOR 129 16,641 2,452 3,723.9 446.9 (~7.4 min) <p>Throughput stays close to 10.6 million cell-iterations per second for both solvers; iteration count is the dominant lever on runtime.</p>"},{"location":"developer-guide/implementation/solver-benchmarks/#cg-solver-notes","title":"CG solver notes","text":"<p>The preconditioned CG solver operates on the same operator but converges in an order of magnitude fewer iterations on most problems. Two practical tips when benchmarking CG:</p> <ul> <li>Warm-starting (<code>--warm-start</code>) on timeline runs typically halves the iteration   count after the first frame.</li> <li>Enabling coarse-to-fine prolongation (<code>--use-prolongation</code>) provides a   high-quality initial guess for fine grids, keeping CG iteration counts   comparable to SOR while meeting tighter tolerances.</li> <li>Switching the preconditioner via <code>--pc {none|jacobi|ssor}</code> can cut iteration   counts dramatically on conductive grids. Jacobi tends to pay off once   \\(\\sigma &gt; 0\\); SSOR is helpful when permeability contrasts exceed 100\u00d7.</li> </ul>"},{"location":"developer-guide/implementation/solver-benchmarks/#3-benchmark-workflow","title":"3. Benchmark workflow","text":"<ol> <li>Build the tool: <code>cmake --build build --target solver_benchmark -j</code>.</li> <li>Run with custom parameters. Example:</li> </ol> <pre><code>./build/solver_benchmark --nx 201 --ny 201 --omega 1.9 --tol 1e-6 --repeats 5\n</code></pre> <ol> <li>Optional: append to a CSV log for historical comparison using    <code>--csv outputs/solver_benchmarks.csv</code>.</li> </ol> <p>The binary resets the solution between repeats so the reported timings are not influenced by warm caches from previous runs. Include the hardware description whenever posting new numbers to this table.</p>"},{"location":"developer-guide/implementation/solver-benchmarks/#4-recommendations-for-automated-tests","title":"4. Recommendations for automated tests","text":"<ul> <li>Keep CI-oriented tests at \u2264 201\u00b2 cells with \\(\\omega\\) tuned for rapid   convergence.</li> <li>Increase tolerances (e.g., <code>tol = 5e-6</code>) for exploratory notebooks to trade   accuracy for turnaround.</li> <li>Use the CSV logging mode when experimenting with algorithmic tweaks so   performance regressions are easy to detect.</li> </ul>"},{"location":"developer-guide/implementation/solver-benchmarks/#5-estimating-simulation-turnaround","title":"5. Estimating simulation turnaround","text":"<p>To approximate wall-clock runtime for a new configuration:</p> <ol> <li>Decide which solver you intend to use and locate the closest grid size in   <code>docs/solver_benchmark/benchmark/solver_scaling_summary.txt</code>.</li> <li>For CG, scale from the \\(1.82 \\times 10^{-7} N^3\\) fit; for SOR, start from   the \\(1.07 \\times 10^{-8} N^{4.05}\\) estimate and adjust using the measured   per-cycle numbers above.</li> <li>Multiply the per-solve time by the number of timeline frames (or reuse the   <code>~seconds per 120-frame cycle</code> column if your export matches that cadence).</li> <li>Apply warm-start and prolongation discounts where applicable (40\u201360% savings   are common once the first frame converges).</li> </ol> <p>These heuristics assume strictly single-threaded execution. Parallelisation (not yet wired in for the production solvers) or different build types will shift the absolute numbers, but the scaling slopes remain a reliable rule of thumb.</p>"},{"location":"developer-guide/implementation/status/","title":"Next-Stage Plan Implementation Status","text":"<p>This document tracks progress against the \"Next-Stage Development Plan \u2014 Time Series, Forces, and Advanced Probes\" roadmap.</p>"},{"location":"developer-guide/implementation/status/#stage-progress-from-magnetostatics-to-basic-motor-simulation","title":"Stage progress \u2014 From Magnetostatics to Basic Motor Simulation","text":"<ul> <li>Stage 0.1 (SIMD-ready linops): Extracted the core linear algebra kernels   (<code>applyA</code>, dot products, axpy/scal, residual norms) into <code>motorsim::linops</code>   with optional vectorisation hints guarded by the new   <code>MOTORSIM_ENABLE_SIMD_HINTS</code> CMake switch (<code>-DMOTORSIM_SIMD_HINTS</code>). Solver   code now routes through these utilities, paving the way for SIMD or threaded   back-ends without changing behaviour.</li> <li>Stage 0.2 (Live progress polish): Expanded the runtime controls with   <code>--progress-every</code>, <code>--snapshot-every</code>, and the new <code>--progress-history</code>   output. The CLI now records residual samples to CSV (timeline runs append   <code>_frame_###</code>), enabling CI to archive a long CG history directly from   <code>motor_sim</code>.</li> <li>Stage 1 (Three-phase synchronous baseline): Restored   <code>python/gen_three_phase_stator.py</code> to emit the original stator-only rotating   field demo. The generator continues to supply CI and hi-res profiles, and   <code>docs/three_phase_stator.md</code> focuses on the bore-angle regression   (<code>python/check_three_phase_field.py</code>), ParaView <code>.pvd</code> series, and animation   workflow without introducing rotor geometry. Maxwell-stress and back-EMF   probes remain available for stator studies, with regression coverage in   <code>tests/back_emf_probe_test.cpp</code>.</li> <li>Stage 2.1 (RL circuit co-simulation): Scenario JSON now accepts   lumped-element circuits with per-phase resistors, inductors, voltage sources,   and coil links. Timeline frames drive the network via   <code>\"voltage_sources\"</code>, the solver integrates branch currents with RK4 (while   feeding back <code>-d\u03bb/dt</code> from coil flux), and the new   <code>python/gen_three_phase_pm_motor.py</code> emits the default three-phase star   connection for the permanent-magnet motor demo. <code>tests/circuit_rk_test.cpp</code>   exercises the RK integrator against the analytic RL step response, and   <code>docs/three_phase_pm_motor.md</code> documents the voltage-driven workflow. The   <code>current_region</code> source now records slot turns and copper fill fraction so the   rasteriser deposits ampere-turns instead of raw current; coil links validate   the turn count so the circuit and field models stay in sync, and the new   <code>tests/current_region_turns_test.cpp</code> regression integrates the deposited   density to keep the ampere-turn budget within 5% of the analytic target.   Each scenario can now request a <code>circuit_trace</code> output; the runtime records   per-coil current, ampere-turn, and back-EMF histories so downstream tooling   (notably <code>python/generate_rotor_animation.py</code>) can colour stator slots by the   solved waveforms. CI archives these CSVs for the PM, induction, and DC motor   demos and renders rotor-only GIF/PNG snapshots alongside the field-map   animations.   Follow-up work introduced commutator metadata on <code>coil_link</code> entries so coil   orientation can depend on rotor angle. <code>CircuitSimulator</code> now reads per-link   segment tables, queries the current <code>dc_rotor</code> angle from the mechanical or   timeline state, and applies the requested sign flip before depositing currents   or integrating flux. The DC motor generator (<code>python/gen_dc_motor.py</code>) uses   this plumbing to emit a brushed armature demo alongside a four-frame   <code>commutator_test</code> fixture. <code>tests/dc_commutator_test.cpp</code> confirms the   orientation switching logic, while <code>tests/dc_motor_spinup_test.cpp</code> exercises   the full EM/circuit/mechanical loop with balanced stator and rotor ampere-turn   budgets. Documentation lives in <code>docs/dc_commutated_motor.md</code>, and CI now runs   the generator, solver, and mechanical validator to archive the new artefacts.</li> <li>Stage 2.2 (Mechanical coupling): Introduced a light-weight rotor   dynamics module that integrates speed and position via RK4 using the torque   reported by Maxwell-stress probes. Scenarios can now declare inertial,   damping, and load torque terms under <code>\"mechanical\"</code>; the PM motor generator   provides a default configuration with a constant load, and the runtime keeps   timeline frames sequential to ensure warm-started field solves feed the   coupled ODE. The integrator automatically stands down when timeline frames   provide explicit rotor angles so deterministic synchronous demos (e.g. the PM   motor walkthrough) keep their scripted pose, while scenarios without those   overrides step the coupled mechanics. <code>tests/mechanical_spinup_test.cpp</code>   verifies the integrator against a constant-torque spin-up. Follow-up fixes   ensure timeline exporters respect basenames that already end in <code>_frame</code>,   restoring the expected <code>three_phase_frame_000.vti</code> artefact that CI archives   for the stator rotating-field demo, and the new   <code>tests/pm_motor_spinup_test.cpp</code> regression drives the full EM/circuit/mechanical   loop to assert the rotor angle and speed rise over a short spin-up timeline   while the CLI exposes a <code>mechanical_trace</code> output so CI and users can verify   the rotor state history via <code>python/check_pm_spinup.py</code>. The PM motor guide now   summarises the CI fixture parameters and documents lighter generator overrides   for local smoke tests so developers can iterate without modifying the stored   regression JSON. The generator now carves the magnet out of the rotor iron,   assigns it \u03bc\u1d63\u22481.05, and trims the magnet strength (1\u00d710\u2075\u202fA/m) alongside the   phase drive (35\u202fA peak warm-start currents, 20\u202fV peak). The rotor bore field   therefore stays on the same tens-of-millitesla scale as the stator-only demo   instead of spiking into the 50\u2013200\u202fT range that occurred when the magnet   inherited the 800\u00d7 permeability of the surrounding steel. Timeline solves now   aggregate torque probe samples into the requested base path   (<code>time_s,frame_index,Fx,Fy,Tz[,CoEnergy]</code>) so the PM, DC, and induction   spin-up demos expose ready-to-plot torque histories without scraping   individual <code>_frame_###</code> files. Follow-on cleanup reduced the CI tessellation   counts (18 stator vertices, 12 for the bore, 10 for the rotor loop) so the   committed spin-up fixture stays close to 1.3k lines, and the   <code>python/check_pm_spinup.py</code> helper now evaluates absolute angle/speed gains to   accommodate rotors that accelerate in either direction. The brushed DC spin-up   fixture now caps the CI profile at two electrical cycles (24 frames) so the   archived mechanical trace remains monotonic for the commutator regression,   while the hires preset retains the longer six-cycle sweep for offline studies.</li> <li>Stage 3 (Frequency-domain induction path): Extended the material schema   with per-material conductivities (<code>sigma</code>) and taught the rasteriser and grid   container to track <code>sigma</code>, complex impressed currents, and an imaginary   vector potential. A new harmonic solver assembles the coupled real/imaginary   system and applies CG to the normal equations so frequency-domain eddy   currents can be simulated without leaving the matrix-free framework. Utility   routines compute complex \\(\\mathbf{B}\\) and \\(\\mathbf{H}\\) fields, and the   regression <code>tests/skin_depth_test.cpp</code> validates skin-depth decay against the   analytic \\(e^{-x/\\delta}\\) profile for a half-space conductor, enforcing a   \u226415% slope error on the bundled scenario.</li> <li>Stage 4 (Transient magnetodynamics foundations): Introduced a   Crank\u2013Nicolson-style transient wrapper that augments the existing matrix-free   operator with \\(\\sigma/\\Delta t\\) mass terms and reuses the CG machinery (and   preconditioners) to march conductive regions forward in time. Timeline frames   now opt into transient solves via the <code>\"transient\"</code> block, and the main loop   detects when scripted rotor angles are absent so the coupled circuit/mechanical   subsystems advance in lock-step with the EM step. The regression   <code>tests/diffusion_test.cpp</code> drives the new   <code>inputs/tests/diffusion_test.json</code> scenario to check magnetic diffusion into a   conducting slab against the analytic erfc profile, enforcing a \u226420% envelope   error while archiving the recovered surface field amplitude. Stage 4.2 now ships   an induction spin-up path: <code>python/gen_three_phase_induction_motor.py</code> emits a   conductive-bar rotor demo, <code>tests/induction_spinup_test.cpp</code> verifies the coupled   transient/mechanical loop accelerates the rotor while staying below synchronous   speed, and CI captures the accompanying VTK/mechanical artefacts.</li> <li>Stage 5 (Solver UX/perf prep): Added a <code>--pc {none|jacobi|ssor}</code> CLI flag   and matching scenario schema to control CG preconditioners. Jacobi and a   matrix-free SSOR sweep are exposed as first-class options, documented in the   solver guide alongside usage tips. The default remains unpreconditioned, but   CI, the local workflow helper, and the docs now spell out when Jacobi or SSOR   provide faster convergence on conductive or highly anisotropic cases.</li> </ul>"},{"location":"developer-guide/implementation/status/#completed-milestones","title":"Completed Milestones","text":"<ul> <li>VTK export and verification: Implemented via <code>motorsim::write_vti_field_map</code> with regression coverage in <code>tests/output_quantity_test.cpp</code> and exercised in CI through the rotor ripple timeline artefacts. Exports now bundle combined <code>B</code>/<code>H</code> vector arrays plus geometry outline polydata companions to streamline ParaView workflows. The <code>python/verify_vtk.py</code> utility (documented in <code>docs/vtk_output.md</code>) runs during CI to sanity-check the generated <code>.vti</code> files.</li> <li>Time-series infrastructure: Scenario timelines, per-frame solving, and parallel execution are available (see <code>docs/time_series.md</code>). Rotors now group geometry, magnets, and sources under named pivots so timeline frames can rotate complete assemblies via the new <code>rotor_angles</code> overrides. The CI workflow drives <code>inputs/tests/rotor_ripple_test.json</code> with <code>--parallel-frames</code> to emit multi-frame datasets and CSV/VTI artefacts.</li> <li>Maxwell stress probes: Force/torque evaluation and documentation reside in <code>docs/torque_forces.md</code>, with validation fixtures in <code>tests/torque_validation_test.cpp</code> and rotor ripple torque ripple checks.</li> <li>Back-EMF probes: Flux integration across timeline frames emits per-interval voltages (<code>docs/back_emf.md</code>) and is now represented in the artefact bundle via <code>outputs/rotor_ripple_emf.csv</code>.</li> <li>Visualization upgrades: <code>python/visualize_scenario_field.py</code> exposes log-scale colormaps, boundary overlays, streamline controls, analytic overlays, and vector scaling modes (documented in <code>docs/visualization.md</code>). CI renders both static validation scenes and the new rotor ripple frames.</li> <li>Rotor animation toolkit: <code>python/rotor_animation.py</code> + <code>python/generate_rotor_animation.py</code> now turn scenario geometry, mechanical traces, and circuit currents into coloured slot animations. The PM, induction, and DC demos request <code>circuit_trace</code> outputs so the helper can tint slots by ampere-turns; CI runs capture both GIF and PNG artefacts, and <code>tests/rotor_animation_smoke.py</code> covers the CLI in both explicit-trace and timeline-fallback modes.</li> </ul>"},{"location":"developer-guide/implementation/status/#ci-artefact-coverage","title":"CI artefact coverage","text":"<ul> <li>Field plots: <code>ci_artifacts/rotor_ripple_frame0.png</code> and <code>ci_artifacts/rotor_ripple_frame2.png</code> illustrate timeline evolution alongside the existing two-wire/interface/iron-ring renders.</li> <li>Accuracy reports: <code>ci_artifacts/test_accuracy_report.txt</code> aggregates analytic/regression solver comparisons, now including force, torque, and back-EMF validation summaries captured from the dedicated regression binaries; additional torque/back-EMF CSVs are copied directly from <code>outputs/</code>.</li> <li>Sample VTK: <code>outputs/rotor_ripple_field_frame_000.vti</code> (and subsequent frames) are exported on every CI run and verified with <code>python/verify_vtk.py</code>. Companion outline polydata and <code>_labels.csv</code> mapping files are uploaded for ParaView inspection.</li> <li>Rotor timeline bundles now rotate a multi-segment rotor and high-\u00b5 stator, emit outline polydata that ParaView can load without crashing, and log symmetry metrics (<code>opposition60_120</code>, <code>repeat0_180</code>) plus relative probe/back-EMF errors in the regression summary to track solver accuracy over time.</li> </ul>"},{"location":"developer-guide/implementation/status/#high-compute-follow-up-runs","title":"High-compute follow-up runs","text":"<p>The CI fixtures intentionally stay coarse (\u226465\u00d765 grids with short timelines). When more compute is available, regenerate the following scenarios with their <code>hires</code> profiles to produce denser artefacts, longer spin-ups, or complete electrical cycles:</p> <ul> <li><code>python/gen_three_phase_stator.py --profile hires --out inputs/three_phase_stator_hires.json</code>   followed by <code>./build/motor_sim --scenario inputs/three_phase_stator_hires.json --solve --vtk-series outputs/three_phase_hires.pvd</code>   to render the 401\u00d7401 bore field sweep.</li> <li><code>python/gen_three_phase_pm_motor.py --profile hires --mode spinup --out inputs/pm_motor_spinup_hires.json</code>   then <code>./build/motor_sim --scenario inputs/pm_motor_spinup_hires.json --solve --vtk-series outputs/pm_motor_hires.pvd</code>   for a multi-cycle permanent-magnet spin-up with higher polygon resolution.</li> <li><code>python/gen_three_phase_induction_motor.py --profile hires --mode spinup --out inputs/induction_motor_hires.json</code>   and <code>./build/motor_sim --scenario inputs/induction_motor_hires.json --solve --vtk-series outputs/induction_motor_hires.pvd</code>   to capture the transient slip behaviour over several mechanical revolutions.</li> <li><code>python/gen_dc_motor.py --profile hires --mode spinup --out inputs/dc_motor_spinup_hires.json</code>   with <code>./build/motor_sim --scenario inputs/dc_motor_spinup_hires.json --solve --vtk-series outputs/dc_motor_hires.pvd</code>   to inspect the commutated armature waveforms and torque under finer discretisation.</li> <li>After each hires solve, re-run <code>python/generate_rotor_animation.py</code> with the   emitted mechanical and circuit traces to capture high-resolution GIF/PNG   animations (matching the CI commands but pointing at the hires scenario and   output directories). The rotor animation helper consumes both timeline data   and recorded currents, so the hires artefacts retain the correct slot colour   modulation.</li> <li>For all of the above, re-run <code>python/check_pm_spinup.py</code> with the emitted   <code>--mechanical</code> traces and loosened thresholds to validate the long-horizon   acceleration, and archive the residual CSVs (<code>--progress-history 1</code>) alongside   the high-resolution VTK artefacts.</li> </ul>"},{"location":"developer-guide/implementation/status/#remaining-work","title":"Remaining work","text":"<ul> <li>Additional UX polish (e.g., non-uniform grid bands and parallel CG kernels)   can build on the new preconditioner hooks once the transient pipeline settles.   Longer transient runs that co-simulate the RL network, slip-tuned voltage   sources, and coarse-to-fine prolongation for induction demos remain on the   wishlist alongside the optional mechanical enhancements from Stage 5.</li> </ul>"},{"location":"developer-guide/implementation/validation-stages/","title":"Analytical Validation Ladder","text":"<p>The analytical validation ladder mirrors the \"Next-Stage Development Plan \u2014 Time Series, Forces, and Advanced Probes\" roadmap. Each rung pairs a solvable scenario with an automated regression test so we can quantify agreement with closed-form physics before escalating to full motor geometries.</p>"},{"location":"developer-guide/implementation/validation-stages/#stage-summary","title":"Stage summary","text":"Stage Scenario / Test Analytic reference Acceptance check 1 <code>tests/analytic_wire_test</code> (<code>inputs/tests/analytic_wire_test.json</code>) Biot\u2013Savart field of an infinite line current RMS relative error of sampled |B| at a 5\u00a0cm radius ring below 25%. 2 <code>tests/magnet_strip_test</code> (<code>inputs/tests/magnet_strip_test.json</code>) Surface-current model of a uniformly magnetised slab RMS relative error of |B| along the midline &lt; 15% and Hy inside the magnet near zero. 2a <code>tests/current_region_turns_test</code> (<code>inputs/tests/current_region_turns_test.json</code>) Ampere-turn conservation for polygonal slot sources Integrated current density matches the requested ampere-turns within 5%. 3 <code>tests/torque_validation_test</code> (<code>inputs/tests/torque_validation_test.json</code>) Torque on a dipole in an external field Maxwell stress tensor torque agrees with dipole and virtual-work estimates within 20% / 25%, respectively. 4 <code>tests/back_emf_probe_test</code> (<code>inputs/tests/back_emf_probe_test.json</code>) Faraday law using discrete flux differences Polygon and rectangular probes integrate flux exactly for synthetic fields and produce the expected EMF between frames. 5 <code>tests/rotor_ripple_test</code> (<code>inputs/tests/rotor_ripple_test.json</code>) Quasi-static PM rotor in a stator field Torque sign flips as the rotor sweeps 0\u00b0\u2192180\u00b0 and the simulated peak-to-peak ripple exceeds 0.3\u00a0N\u00b7m\u00b7m\u207b\u00b9. 6 <code>tests/skin_depth_test</code> (<code>inputs/tests/skin_depth_test.json</code>) Classical skin-depth decay in a conducting half-space Linear-fit slope of ( 7 <code>tests/diffusion_test</code> (<code>inputs/tests/diffusion_test.json</code>) Semi-infinite magnetic diffusion following the error-function solution Max relative error of sampled \\(B_x\\) vs \\(\\mathrm{erfc}\\) profile stays below 20%. 8 <code>tests/dc_commutator_test</code> (<code>inputs/tests/dc_commutator_test.json</code>) Commutator segment sweep Armature regions flip sign at \u00b190\u00b0 exactly as specified; no missed segments. 9 <code>tests/dc_motor_spinup_test</code> (<code>inputs/tests/dc_motor_spinup_test.json</code>) Brushed DC motor spin-up Rotor angle rise &gt; 8\u202fdeg, speed rise &gt; 5\u202frad\u00b7s\u207b\u00b9, final speed \u2260 0. 10 <code>tests/induction_spinup_test</code> (<code>inputs/tests/induction_spinup_test.json</code>) Slip-limited acceleration of a conductive rotor Rotor angle/speed rise &gt; 5\u202fdeg / 5\u202frad\u00b7s\u207b\u00b9, final speed &lt; 80% synchronous, slip within (0.05, 0.95). <p>All tests execute via <code>ctest</code> (see <code>CMakeLists.txt</code>) and run as part of the GitHub Actions workflow. They share compact domains so the Gauss\u2013Seidel solver converges within a few seconds per frame.</p>"},{"location":"developer-guide/implementation/validation-stages/#scenario-notes","title":"Scenario notes","text":"<ul> <li>Stage 1: The analytic wire scenario writes CSV artefacts for regression plots. The <code>python/visualize_wire.py</code> helper overlays the Biot\u2013Savart solution and is used in CI artefact generation.</li> <li>Stage 2: The magnet strip benchmark samples the field along <code>y=0</code> and compares against a 4,000-segment surface-current quadrature. It also confirms that the magnet interior is nearly demagnetised (Hy \u2248 0).</li> <li>Stage 2a: The current-region turns test integrates the rasterised <code>J_z</code> over a coil slot polygon to ensure the deposited ampere-turns stay within 5% of the analytic <code>orientation \u00d7 I \u00d7 turns \u00d7 fill_fraction</code> target.</li> <li>Stage 3: The torque validation setup places a rectangular magnet between counter-wound conductors. The magnet experiences a uniform transverse field so the torque can be predicted from <code>\u03c4 = (M \u00b7 A) \u00d7 B</code>. The regression checks both the Maxwell stress integration and a virtual-work finite difference (<code>\u0394W/\u0394\u03b8</code>).</li> <li>Stage 4: The back-EMF test exercises polygonal and rectangular integration regions, verifies frame selection semantics, and validates the EMF series using synthetic flux ramps.</li> <li>Stage 5: The rotor ripple scenario reuses the Stage\u00a03 geometry but sweeps the magnetisation vector through four angles (0\u00b0, 60\u00b0, 120\u00b0, 180\u00b0) via timeline frames. The regression ensures torque polarity and amplitude evolve consistently with the expected sinusoid.</li> <li>Stage 6: The skin-depth fixture drives a uniform conductor slab with a harmonic current sheet. Sampling \\(|\\mathbf{B}|\\) along the conductor normal and fitting a log-linear slope recovers the expected \\(-1/\\delta\\) decay constant.</li> <li>Stage 7: The diffusion regression excites a semi-infinite conductor with a step current and marches the transient solve forward using the \\(\\sigma/\\Delta t\\) mass term. Averaging \\(B_x\\) across the slab height and comparing against the analytic \\(\\mathrm{erfc}\\) profile enforces the \u226420% envelope error target.</li> <li>Stage 8: The commutator regression sweeps the <code>dc_rotor</code> through four scripted angles and asserts that both armature regions inherit the expected sign flips from their segment tables without touching the EM solver.</li> <li>Stage 9: The brushed DC spin-up regression runs the full EM/circuit/mechanical pipeline, ensuring the commutated armature continues to produce positive torque (angle rise \u2265\u202f8\u00b0, speed rise \u2265\u202f5\u202frad\u00b7s\u207b\u00b9) while recording the mechanical trace CI archives alongside the three-phase demos.</li> <li>Mechanical spin-up: <code>tests/pm_motor_spinup_test.cpp</code> loads the coupled PM motor spin-up scenario, solving the EM field,   RL circuits, and RK4 mechanical loop frame-by-frame. The regression asserts that rotor angle and speed rise over the timeline,   mirroring the CI spin-up demo that writes <code>pm_motor_spinup_mechanical.csv</code> for further inspection.</li> <li>Induction spin-up: <code>tests/induction_spinup_test.cpp</code> exercises the transient Crank\u2013Nicolson solver and the mechanical   integrator on the conductive-bar rotor. It reuses the torque probe to advance the rotor, checks that acceleration is positive,   and ensures the final speed remains below synchronous so slip stays realistic. CI archives the accompanying mechanical trace,   VTK series, and outline polydata.</li> </ul>"},{"location":"developer-guide/implementation/validation-stages/#running-the-ladder-locally","title":"Running the ladder locally","text":"<pre><code>cmake --build build\nctest --output-on-failure -R \"analytic_wire|magnet_strip|torque_validation|back_emf_probe|rotor_ripple\"\n</code></pre> <p>The command above rebuilds the project and runs only the validation ladder tests. Use <code>ctest --output-on-failure --parallel $(nproc)</code> for the full suite to keep turnaround tight.</p>"},{"location":"developer-guide/implementation/validation-stages/#extending-the-ladder","title":"Extending the ladder","text":"<p>Future validation efforts (e.g., laminated stators, eddy-current suppression) should add a dedicated scenario JSON, an automated regression, and a short documentation update. The ladder table gives a template for summarising accuracy targets and analytic references.</p>"},{"location":"developer-guide/math-and-solver/back-emf/","title":"Back-EMF Probes","text":"<p>Back-electromotive-force (back-EMF) measurements estimate the voltage induced in coils by changing magnetic flux across timeline frames. A back-EMF probe samples the field map inside a user-defined loop, records the flux for each solved frame, and post-processes consecutive pairs to produce \\(-\\Delta \\Phi / \\Delta t\\).</p>"},{"location":"developer-guide/math-and-solver/back-emf/#json-schema","title":"JSON schema","text":"<p>Declare probes in the scenario <code>outputs</code> array:</p> <pre><code>{\n  \"type\": \"back_emf_probe\",\n  \"id\": \"stator_phase_a\",\n  \"component\": \"Bx\",\n  \"region\": {\n    \"type\": \"polygon\",\n    \"vertices\": [\n      [-0.02, -0.01],\n      [0.02, -0.01],\n      [0.02, 0.01],\n      [-0.02, 0.01]\n    ]\n  },\n  \"frames\": [0, 1, 2, 3]\n}\n</code></pre> <ul> <li><code>component</code> chooses which magnetic flux-density component to integrate.   Supported values are <code>\"Bx\"</code>, <code>\"By\"</code>, and <code>\"Bmag\"</code> (the default). Use <code>Bx</code>   or <code>By</code> when the coil surface is predominantly pierced by one in-plane field   component.</li> <li><code>region</code> describes the integration area. Provide either a polygon (three or   more vertices) or a rectangle via <code>{\"type\": \"rect\", \"x_range\": [...],   \"y_range\": [...]}</code>.</li> <li><code>frames</code> is optional. When omitted the probe spans every frame in the   timeline. Provide at least two frame indices when you need a sparse subset.</li> <li><code>path</code> is optional; by default results are written to   <code>outputs/&lt;id&gt;_emf.csv</code>.</li> </ul>"},{"location":"developer-guide/math-and-solver/back-emf/#output-format","title":"Output format","text":"<p>Back-EMF probes write a single CSV containing one row per interval between frames:</p> <pre><code>frame_start,frame_end,t_start,t_end,delta_t,flux_start,flux_end,emf\n0,1,0.000000000000e+00,1.000000000000e-03,1.000000000000e-03,0.000000000000e+00,2.500000000000e-03,-2.500000000000e+00\n</code></pre> <p>Columns describe the contributing frames, their timestamps, the integrated flux (values are in webers per metre), and the induced voltage per unit length in volts per metre. When timelines are absent or only one frame is available, the solver reports an error because \\(\\Delta t\\) would be undefined.</p>"},{"location":"developer-guide/math-and-solver/back-emf/#python-api","title":"Python API","text":"<p>The <code>BackEmfProbeOutput</code> helper mirrors the JSON schema:</p> <pre><code>from scenario_api import BackEmfProbeOutput\n\noutput = BackEmfProbeOutput(\n    id=\"phase_a\",\n    component=\"By\",\n    vertices=[(-0.01, -0.02), (0.01, -0.02), (0.01, 0.02), (-0.01, 0.02)],\n    frames=[0, 2, 4],\n)\n</code></pre> <p>Combine with <code>Scenario.outputs.append(output)</code> before calling <code>save_json</code>.</p>"},{"location":"developer-guide/math-and-solver/back-emf/#numerical-notes","title":"Numerical notes","text":"<ul> <li>Flux is approximated by averaging the requested component over cell centres   inside the region and multiplying by the cell area (per-unit-length measure).</li> <li>When <code>component=\"Bmag\"</code> the solver integrates the magnitude of B, which is   helpful when the dominant component varies with rotor angle but introduces an   approximation.</li> <li>Timeline timestamps should be monotonic and distinct; the solver raises an   error if two consecutive frames share the same time value.</li> <li>Back-EMF probes operate on field-map data. They do not expand the flux by the   slot\u2019s turn count; multiply the reported voltage per unit length by the   active stack length and the <code>turns</code> assigned to the corresponding   <code>current_region</code> to obtain phase voltages. Circuit-driven coils perform this   multiplication automatically because coil-link entries and regions now share   the same turn count. The three-phase PM motor demo integrates the flux   magnitude over each phase\u2019s positive slot to produce a sinusoidal reference   waveform that lines up with the rotating air-gap field.</li> <li><code>fill_fraction</code> on <code>current_region</code> sources only affects how ampere-turns are   deposited when solving the field; it does not change the flux integration   geometry. Use it to approximate copper packing while keeping the probe region   equal to the physical slot outline.</li> <li><code>tests/back_emf_probe_test.cpp</code> drives the integration helper with synthetic   three-phase flux waveforms, verifying that the induced EMFs follow the   expected sinusoidal shape, maintain 120\u00b0 phase separation, and scale with both   flux amplitude and electrical speed.</li> </ul>"},{"location":"developer-guide/math-and-solver/fundamentals/","title":"Magnetostatic Solver Math Notes","text":"<p>This document summarizes the equations, discretizations, and validation strategy used by the minimal 2D magnetostatic solver implemented in this repository. It follows the scalar potential formulation with a single non-zero component \\(A_z(x, y)\\) and highlights practical implementation details for the structured grid solver. Reusable notation is collected under Reference \u2192 Equations.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#1-problem-statement-2d-magnetostatics","title":"1. Problem statement: 2D magnetostatics","text":"<p>We consider a 2D Cartesian cross-section where impressed currents are directed along the out-of-plane \\(z\\)-axis. The vector potential has only one non-zero component,</p> \\[ \\mathbf{A} = (0, 0, A_z(x, y)). \\] <p>The magnetic flux density is recovered by taking the curl of \\(\\mathbf{A}\\):</p> \\[ \\mathbf{B} = \\nabla \\times (0, 0, A_z) = \\bigl(\\partial_y A_z,\\; -\\partial_x A_z,\\; 0\\bigr). \\] <p>Consequently,</p> \\[ B_x = \\partial_y A_z, \\qquad B_y = -\\partial_x A_z. \\]"},{"location":"developer-guide/math-and-solver/fundamentals/#2-governing-pde","title":"2. Governing PDE","text":"<p>Spatially varying materials are represented through the magnetic permeability \\(\\mu(x, y) = \\mu_0 \\mu_r(x, y)\\). The scalar potential satisfies the Poisson-like equation</p> \\[ \\nabla \\cdot \\left( \\frac{1}{\\mu} \\nabla A_z \\right) = -J_z, \\] <p>where \\(J_z\\) is the impressed current density in the \\(z\\) direction. In the special case of uniform permeability, \\(\\mu = \\text{const}\\), the equation reduces to</p> \\[ \\nabla^2 A_z = -\\mu J_z. \\]"},{"location":"developer-guide/math-and-solver/fundamentals/#3-discretization-on-a-uniform-grid","title":"3. Discretization on a uniform grid","text":"<p>The solver operates on a structured, uniform grid of size \\((n_x, n_y)\\) with spacings \\(\\Delta x, \\Delta y\\). All quantities are stored at cell centres:</p> <ul> <li>\\(A_z\\): vector potential solution. In harmonic solves the code also stores an imaginary component \\(A_z^{(i)}\\).</li> <li>\\(J_z\\): source term. A companion array stores the imaginary impressed current density when frequency-domain sources are used.</li> <li>\\(\\nu = 1/\\mu\\): inverse permeability.</li> <li>\\(\\sigma\\): electrical conductivity (S/m), required for eddy-current calculations.</li> </ul>"},{"location":"developer-guide/math-and-solver/fundamentals/#31-variable-coefficient-five-point-stencil","title":"3.1 Variable-coefficient five-point stencil","text":"<p>Spatially varying materials require carefully averaging \\(\\nu\\) across cell faces. Using harmonic averages preserves flux continuity across interfaces. For the east face shared by cells \\((i, j)\\) and \\((i+1, j)\\),</p> \\[ \\nu_E = \\frac{2\\,\\nu_{i,j}\\,\\nu_{i+1,j}}{\\nu_{i,j} + \\nu_{i+1,j}}, \\] <p>with analogous expressions for the west (W), north (N), and south (S) faces. These face coefficients yield the standard five-point stencil for diffusion with variable coefficients. The Gauss\u2013Seidel point update used by the solver reads</p> \\[ A_{i,j}^{(\\text{new})} = \\frac{ \\tfrac{\\nu_E}{\\Delta x^2} A_{i+1,j} + \\tfrac{\\nu_W}{\\Delta x^2} A_{i-1,j} + \\tfrac{\\nu_N}{\\Delta y^2} A_{i,j+1} + \\tfrac{\\nu_S}{\\Delta y^2} A_{i,j-1} + J_{i,j} }{ \\tfrac{\\nu_E + \\nu_W}{\\Delta x^2} + \\tfrac{\\nu_N + \\nu_S}{\\Delta y^2} }. \\] <p>When \\(\\mu\\) is uniform, \\(\\nu_E = \\nu_W = \\nu_N = \\nu_S = 1/\\mu\\) and the update reduces to the familiar five-point Laplacian.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#32-discrete-residual","title":"3.2 Discrete residual","text":"<p>The residual used for convergence checks is assembled directly from the fluxes through each face:</p> \\[ R_{i,j} = \\frac{\\nu_E (A_{i+1,j} - A_{i,j}) - \\nu_W (A_{i,j} - A_{i-1,j})}{\\Delta x^2} + \\frac{\\nu_N (A_{i,j+1} - A_{i,j}) - \\nu_S (A_{i,j} - A_{i,j-1})}{\\Delta y^2} - J_{i,j}. \\] <p>The continuous PDE is satisfied when \\(R_{i,j} = 0\\) everywhere.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#4-boundary-conditions","title":"4. Boundary conditions","text":"<p>The solver supports both Dirichlet and homogeneous Neumann boundary conditions on the outer rectangular boundary. Dirichlet fixes \\(A_z = 0\\), emulating a bounding conductor. Neumann enforces \\(\\partial_n A_z = 0\\) so flux can exit without forcing a return through the box. In the Gauss\u2013Seidel sweep the Neumann option mirrors the adjacent interior value into the boundary cell, making the forward difference for the normal derivative vanish.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#5-iterative-solvers","title":"5. Iterative solvers","text":"<p>The codebase exposes two matrix-free solvers that operate on the same discrete operator:</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#51-gaussseidel-with-sor","title":"5.1 Gauss\u2013Seidel with SOR","text":"<p>The legacy workhorse remains a Gauss\u2013Seidel method with Successive Over-Relaxation (SOR). For every interior cell,</p> \\[ A_{i,j}^{(\\text{new})} = \\frac{\\tfrac{\\nu_E}{\\Delta x^2} A_{i+1,j} + \\tfrac{\\nu_W}{\\Delta x^2} A_{i-1,j} + \\tfrac{\\nu_N}{\\Delta y^2} A_{i,j+1} + \\tfrac{\\nu_S}{\\Delta y^2} A_{i,j-1} + J_{i,j}}{\\tfrac{\\nu_E + \\nu_W}{\\Delta x^2} + \\tfrac{\\nu_N + \\nu_S}{\\Delta y^2}}. \\] <p>Relaxation is applied as</p> \\[ A_{i,j} \\leftarrow (1 - \\omega) A_{i,j} + \\omega A_{i,j}^{(\\text{new})}, \\qquad 1 &lt; \\omega &lt; 2. \\] <p>SOR remains useful as a smoother and a robust fallback when diagnostics are required.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#52-preconditioned-conjugate-gradient-pcg","title":"5.2 Preconditioned Conjugate Gradient (PCG)","text":"<p>For production runs the simulator now provides a preconditioned conjugate gradient solver tailored to the symmetric positive definite system. The PCG iteration is expressed in matrix-free form using the residual assembly routine shown earlier. Users can select a preconditioner at runtime via <code>--pc {none|jacobi|ssor}</code> (or the matching scenario schema). The Jacobi option applies the diagonal inverse of the operator, while the SSOR mode runs a matrix-free symmetric Gauss\u2013Seidel sweep that respects the structured 5-point stencil. The update equations follow the standard PCG recurrence:</p> \\[ \\begin{aligned} r_k &amp;= b - A x_k, &amp; z_k &amp;= M^{-1} r_k, &amp; p_k &amp;= z_k + \\beta_{k-1} p_{k-1}, \\\\ \\alpha_k &amp;= \\frac{r_k^T z_k}{p_k^T A p_k}, &amp; x_{k+1} &amp;= x_k + \\alpha_k p_k, &amp; r_{k+1} &amp;= r_k - \\alpha_k A p_k, \\end{aligned} \\] <p>with \\(\\beta_{k-1} = (r_k^T z_k) / (r_{k-1}^T z_{k-1})\\). The implementation enforces Neumann symmetry by mirroring boundary values between iterations and monitors stagnation. If the relative residual fails to improve over a configurable window the solver emits guidance suggesting warm starts, prolongation, or falling back to SOR for inspection.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#53-transient-magnetodynamics","title":"5.3 Transient magnetodynamics","text":"<p>Conductive regions introduce the magneto-quasistatic equation</p> \\[ \\sigma \\frac{\\partial A_z}{\\partial t} + \\nabla\\cdot\\left(\\nu \\nabla A_z\\right) = -J_{\\text{imp}}, \\] <p>which, after linearising with a Crank\u2013Nicolson step and assuming quasi-static magnetisation, yields the linear system</p> \\[ \\left(\\frac{\\sigma}{\\Delta t}I + \\mathcal{A}\\right) A_z^{n+1} = \\frac{\\sigma}{\\Delta t} A_z^n + J_{\\text{imp}}^{n+1}, \\] <p>where \\(\\mathcal{A}(\\cdot) = -\\nabla\\cdot(\\nu \\nabla \\cdot)\\) is the same operator used in the magnetostatic solve. The implementation reuses the CG/PCG back-end by augmenting the matrix-free stencil with the \\(\\sigma/\\Delta t\\) diagonal term and supplying the adjusted right-hand side. Scenario JSON enables transient marching by adding a top-level <code>\"transient\"</code> block with <code>dt</code> and <code>n_steps</code>, and timeline frames advance sequentially so coupled circuit and mechanical subsystems remain synchronised with the EM state. The bundled diffusion regression (<code>tests/diffusion_test.cpp</code>) exercises this pathway and compares the recovered field against the analytic error-function solution for a step excitation into a half-space conductor.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#6-convergence-criteria","title":"6. Convergence criteria","text":"<p>Iterations continue until either the maximum iteration count is reached or the relative residual falls below the user-specified tolerance:</p> \\[ \\frac{\\lVert R \\rVert_2}{\\lVert J \\rVert_2 + \\varepsilon} &lt; \\text{tol}, \\] <p>with \\(\\varepsilon\\) guarding against zero-current scenarios and the sums taken over all interior cells.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#7-recovering-the-magnetic-flux-density","title":"7. Recovering the magnetic flux density","text":"<p>Given \\(A_z\\), the magnetic flux density components are approximated via finite differences. In the interior we use central differences:</p> \\[ B_x \\approx \\frac{A_{i,j+1} - A_{i,j-1}}{2\\Delta y}, \\qquad B_y \\approx -\\frac{A_{i+1,j} - A_{i-1,j}}{2\\Delta x}. \\] <p>One-sided differences are applied on the domain boundary where neighbours are unavailable.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#8-permanent-magnets-and-magnetisation","title":"8. Permanent magnets and magnetisation","text":"<p>Permanent magnets introduce a prescribed magnetisation \\(\\mathbf{M}(x, y)\\) in addition to impressed current density. In the \\(A_z\\) formulation, magnetisation appears as an effective bound current density \\(J_{m,z} = \\partial_x M_y - \\partial_y M_x\\). The rasteriser stores uniform magnetisation vectors per cell and applies finite-difference curls to deposit this contribution into \\(J_z\\). The magnetisation field is also retained so that the magnetic field intensity can be reconstructed after the solve.</p> <p>Given the flux density components, the solver supplies \\(\\mathbf{H}\\) via</p> \\[ \\mathbf{H} = \\nu \\mathbf{B} - \\frac{1}{\\mu_r} \\mathbf{M}, \\qquad \\nu = \\frac{1}{\\mu_0 \\mu_r}. \\] <p>In non-magnetised regions this reduces to the familiar \\(\\mathbf{H} = \\nu \\mathbf{B}\\). Inside permanent magnets the subtraction cancels the remanent contribution, yielding nearly zero \\(\\mathbf{H}\\) for an isolated uniformly magnetised body when \\(\\mu_r \\approx 1\\).</p> <p>The <code>magnet_strip_test</code> regression models a rectangular magnet magnetised along \\(+y\\). The analytic reference treats the magnet as two opposing surface currents and integrates the Biot\u2013Savart kernel along the strip edges. Numerical and analytic \\(B_y\\) agree to within 15%, and the recovered \\(H_y\\) inside the magnet is checked to remain near zero, validating both the bound current deposition and the post-processing of \\(\\mathbf{H}\\).</p> <p>With \\(\\mathbf{B}\\) and \\(\\mathbf{H}\\) reconstructed, the solver additionally evaluates the magnetostatic energy density</p> \\[ w = \\tfrac{1}{2} \\mathbf{B} \\cdot \\mathbf{H} = \\tfrac{1}{2} (B_x H_x + B_y H_y). \\] <p>This scalar is emitted on request and supports energy-based force calculations or quick checks for material saturation.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#9-analytic-reference-planar-permeability-interface","title":"9. Analytic reference: planar permeability interface","text":"<p>To validate heterogeneous permeability handling we leverage the method of images for a line current next to a planar interface. Two media with permeabilities \\(\\mu_1\\) (left, \\(x &lt; 0\\)) and \\(\\mu_2\\) (right, \\(x &gt; 0\\)) meet along the \\(y\\)-axis. A real infinite wire of current \\(I\\) sits at \\(\\mathbf{r}_0 = (-a, 0)\\) inside region 1.</p> <p>The magnetic field in region 1 is the superposition of the real wire and an image wire located at \\(\\mathbf{r}_0' = (+a, 0)\\) with current magnitude scaled by</p> \\[ I' = \\rho I, \\qquad \\rho = \\frac{\\mu_2 - \\mu_1}{\\mu_1 + \\mu_2}. \\] <p>Region 2 sees the field of a \"transmitted\" wire that sits at the real location but carries current</p> \\[ I_t = \\tau I, \\qquad \\tau = \\frac{2\\mu_1}{\\mu_1 + \\mu_2}. \\] <p>For a single infinite wire placed at \\((x_s, y_s)\\) inside a homogeneous medium with permeability \\(\\mu\\), the Biot\u2013Savart expression simplifies in 2D to</p> \\[ \\mathbf{B}(x, y) = \\frac{\\mu I}{2\\pi R^2} \\bigl(-(y - y_s),\\; x - x_s\\bigr), \\qquad R^2 = (x - x_s)^2 + (y - y_s)^2. \\] <p>Therefore the validation procedure assembles</p> <ul> <li>Region 1 field: \\(\\mathbf{B}_1 = \\mathbf{B}_{\\mu_1}(I, \\mathbf{r}_0) + \\mathbf{B}_{\\mu_1}(I', \\mathbf{r}_0')\\).</li> <li>Region 2 field: \\(\\mathbf{B}_2 = \\mathbf{B}_{\\mu_2}(I_t, \\mathbf{r}_0)\\).</li> </ul> <p>Sanity limits include \\(\\rho \\to 0\\) and \\(\\tau \\to 1\\) when \\(\\mu_1 = \\mu_2\\), \\(\\rho \\to 1\\), \\(\\tau \\to 0\\) when \\(\\mu_2 \\to \\infty\\), and \\(\\rho \\to -1\\), \\(\\tau \\to 2\\) as \\(\\mu_2 \\to 0\\).</p> <p>Simulated and analytic \\(|\\mathbf{B}|\\) profiles along vertical probe lines in each half-space provide a sensitive regression on permeability contrast handling. The automated regression focuses on the air-side probe, where the relative error stays below 40% despite the coarse grid and Dirichlet boundary at the outer box.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#10-validation-with-an-infinite-straight-wire","title":"10. Validation with an infinite straight wire","text":"<p>To validate the solver, we model an infinite straight wire carrying current \\(I\\). The analytic magnetic field magnitude is</p> \\[ B(r) = \\frac{\\mu_0 I}{2 \\pi r}. \\] <p>Numerically, the wire is approximated by a small circular region (radius \\(r_c\\)) with uniform current density,</p> \\[ J_z = \\frac{I}{\\pi r_c^2}. \\] <p>Cells with centre radius \\(r \\le r_c\\) receive this current density, while the rest are zero. Choosing \\(r_c\\) a few cells wide (e.g., three cell widths) reduces discretisation error from approximating the singular source. After solving for \\(A_z\\), we compute \\(\\mathbf{B}\\) and sample points along a ring of radius \\(r_{\\text{sample}}\\) to compare the simulated \\(\\lVert \\mathbf{B} \\rVert\\) against the analytic expression. A relative error below 25% is deemed acceptable for the coarse grid and finite domain used in the automated test.</p> <p>This reference captures the mathematical foundations and numerical choices embedded in the minimal solver. Future extensions (e.g., alternative boundary conditions, conjugate gradient solvers, nonlinear materials) should extend these notes accordingly.</p> <p>For runtime and scaling heuristics, consult <code>docs/solver_performance.md</code>, which summarises benchmark data from the bundled tooling.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#11-frequency-domain-magneto-quasistatics","title":"11. Frequency-domain magneto-quasistatics","text":"<p>Conductive regions introduce eddy currents when the magnetic field varies in time. The simulator's first step toward induction modelling solves the steady-state magneto-quasistatic system for sinusoidal excitation. Assuming a phasor dependence \\(e^{j\\omega t}\\) and a scalar potential \\(A_z\\) split into real and imaginary parts (\\(A_z = A_r + j A_i\\)), the governing equations become</p> \\[ \\begin{aligned} \\nabla \\cdot (\\nu \\nabla A_r) - \\omega \\sigma A_i &amp;= J_r, \\\\ \\nabla \\cdot (\\nu \\nabla A_i) + \\omega \\sigma A_r &amp;= J_i, \\end{aligned} \\] <p>where \\(\\sigma\\) is the electrical conductivity and \\(J = J_r + j J_i\\) is the impressed current density. The discrete operator therefore couples the real and imaginary systems through the frequency-dependent \\(\\omega \\sigma\\) term.</p> <p>The implementation keeps the matrix-free structure used by the magnetostatic solver. A helper applies the block operator</p> \\[ \\mathbf{H} = \\begin{bmatrix} L &amp; -\\omega S \\\\ \\omega S &amp; L \\end{bmatrix}, \\] <p>where \\(L\\) is the familiar diffusion stencil and \\(S\\) holds per-cell conductivities. Because \\(\\mathbf{H}\\) is not symmetric, the code forms the normal equations \\(\\mathbf{H}^T \\mathbf{H} x = \\mathbf{H}^T b\\) and solves them with conjugate gradients. Dirichlet boundaries enforce the phasor gauge, and a Jacobi-like preconditioner can be added later without changing the interface.</p> <p>Post-processing mirrors the magnetostatic pipeline: <code>computeBHarmonic</code> evaluates the complex curl of \\(A_z\\) to recover \\(\\mathbf{B}\\), and <code>computeHHarmonic</code> applies \\(\\mathbf{H} = \\nu \\mathbf{B} - \\mathbf{M}/\\mu_r\\) to obtain the magnetic field intensity phasor. The new <code>materials[].sigma</code> property, propagated through <code>Grid2D::sigma</code>, enables eddy terms while keeping legacy magnetostatic scenarios unchanged (\\(\\sigma = 0\\)).</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#12-scenario-spec-v02","title":"12. Scenario Spec v0.2","text":"<p>The solver ingests simulation descriptions authored as JSON documents. Version <code>0.2</code> extends the original schema with heterogeneous material regions while remaining backward compatible with <code>0.1</code> files. A valid document contains the following top-level members:</p> Field Type Notes <code>version</code> string <code>\"0.2\"</code> preferred; <code>\"0.1\"</code> is still recognised for uniform-material scenarios. <code>units</code> string <code>\"SI\"</code> only; currents in amperes, lengths in metres. <code>domain</code> object <code>{Lx, Ly, nx, ny}</code> define the rectangular grid centred on the origin; <code>dx = Lx / (nx-1)</code> and likewise for <code>dy</code>. <code>boundary</code> object Optional boundary condition override, e.g. <code>{ \"type\": \"neumann\" }</code>; defaults to Dirichlet when omitted. <code>materials</code> array Each entry defines <code>{name, mu_r}</code> with unique names. <code>regions</code> array Evaluated in authoring order. Entries may be <code>{\"type\": \"uniform\", \"material\": ...}</code> to set the background, <code>{\"type\": \"halfspace\", \"normal\": [nx, ny], \"offset\": c, \"material\": ...}</code> for planar masks, and <code>{\"type\": \"polygon\", \"vertices\": [[x1, y1], \u2026], \"material\": ...}</code> to paint arbitrary simple polygons. <code>sources</code> array Excites the field solve. Each entry is either a circular <code>{ \"type\": \"wire\", \"x\", \"y\", \"radius\", \"I\" }</code> or a polygonal <code>{ \"type\": \"current_region\", \"vertices\": [...], \"I\", \"turns\", \"fill_fraction\" }</code>. <code>magnet_regions</code> array Optional list of magnetised shapes with uniform magnetisation vectors, e.g. polygon loops or axis-aligned rectangles. <code>outputs</code> array Optional list of export requests. <code>field_map</code> records support <code>quantity</code> values <code>\"B\"</code>, <code>\"H\"</code>, <code>\"BH\"</code>, or <code>\"energy_density\"</code>; <code>line_probe</code> records accept <code>\"Bmag\"</code>, <code>\"Bx\"</code>, <code>\"By\"</code>, <code>\"Hx\"</code>, <code>\"Hy\"</code>, <code>\"Hmag\"</code>, or <code>\"energy_density\"</code>. All outputs are emitted as CSV. <p><code>loadScenarioFromJson</code> validates the structure, normalises half-space normals, and stores the resulting material masks. <code>rasterizeScenarioToGrid</code> then deposits current density and inverse permeability onto a <code>Grid2D</code>. Later region entries override earlier ones so authors can compose layered masks (e.g. a uniform background followed by multiple half-spaces or polygons that carve out subdomains). Polygon masks use an even\u2013odd rule on the provided vertex loop and honour region order, making it easy to emulate cut-outs (e.g. an outer iron annulus followed by an inner air bore).</p> <p>The default CLI continues to wire these stages together:</p> <pre><code>JSON spec \u2192 ScenarioSpec \u2192 rasterise to Grid2D \u2192 solve A_z \u2192 compute B\n</code></pre> <p>Two helper layers keep authoring ergonomic:</p> <ol> <li><code>python/scenario_api.py</code> exposes dataclasses mirroring the schema and a    <code>Scenario.save_json()</code> convenience. The API now includes a <code>HalfspaceRegion</code>    primitive alongside the existing <code>UniformRegion</code>.</li> <li><code>motor_sim --scenario path/to.json --solve [--list-outputs] [--outputs ids]</code>    loads the spec, solves the magnetostatic system, and emits any outputs    declared in the JSON. Use <code>--list-outputs</code> to inspect available IDs and    <code>--outputs id1,id2</code> or <code>--outputs none</code> to control which requests are    fulfilled at runtime. The legacy <code>--write-midline</code> flag remains available for    ad-hoc dumps.</li> </ol> <p>The <code>sources</code> list accepts both circular wires and polygonal current regions. <code>wire</code> entries remain a thin wrapper around the analytic Biot\u2013Savart source: the rasteriser paints a disk of radius <code>r</code> with uniform current density <code>J_z = I / (\u03c0 r\u00b2)</code> wherever the cell centre lies inside the loop. The <code>tests/two_wire_cancel_test.cpp</code> regression integrates the deposited density to confirm that it recovers the requested current to within 15% on the coarse CI grid.</p> <p><code>current_region</code> entries describe coil slots via arbitrary simple polygons. Each region stores an orientation (\u00b11), optional <code>phase</code> label, the conductor current <code>I</code>, the number of turns threading the slot, and a copper packing factor <code>fill_fraction</code>. During rasterisation the simulator distributes the net ampere-turns evenly across the polygon,</p> <pre><code>J_z = (orientation \u00d7 I \u00d7 turns \u00d7 fill_fraction) / area_polygon,\n</code></pre> <p>so that the integrated current density matches the requested ampere-turns even when the slot is only partially filled. The packing factor is clamped to <code>[1e-4, 1]</code> to avoid singular densities, and authors can drive the same slot from voltage-driven circuits (via coil links) or by prescribing timeline currents. <code>tests/current_region_turns_test.cpp</code> integrates the rasterised density and asserts the ampere-turn budget stays within 5% of the analytic value.</p> <p>When a current region is driven by a <code>coil_link</code>, the circuit layer can override its effective orientation via a <code>commutator</code> object:</p> <pre><code>{\n  \"type\": \"coil_link\",\n  \"inductor\": \"arm_L\",\n  \"region\": \"armature_a\",\n  \"turns\": 110.0,\n  \"commutator\": {\n    \"rotor\": \"dc_rotor\",\n    \"default_orientation\": 1.0,\n    \"segments\": [\n      {\"start_deg\": -90.0, \"end_deg\": 90.0, \"orientation\": 1.0},\n      {\"start_deg\": 90.0, \"end_deg\": 270.0, \"orientation\": -1.0}\n    ]\n  }\n}\n</code></pre> <p>At the start of each frame the circuit simulator normalises the associated rotor\u2019s electrical angle, selects the segment whose <code>[start_deg, end_deg)</code> range contains it (wrapping across \u00b1180\u00b0 if needed), and multiplies the base region orientation by the selected <code>orientation</code>. The updated value is used for both current deposition and flux-linkage integration, letting commutated armatures flip polarity without editing the timeline geometry.</p> <p>Magnetised regions live in <code>magnet_regions</code>; each entry supplies a shape (<code>polygon</code> with vertices or <code>rect</code> with <code>x_range</code>/<code>y_range</code>) plus a magnetisation vector <code>magnetization</code> given either as <code>[Mx, My]</code> or <code>{ \"Mx\": ..., \"My\": ... }</code>. Overlapping entries add their vectors. Bound currents are generated from the resulting discrete curl, so partial coverage and composite magnets are supported.</p> <p>Reserved future fields (e.g. a <code>timeline</code> array for time-varying studies) can be introduced without breaking the base schema because the parser ignores unknown members. Additional geometry primitives should extend the <code>regions</code> array with new <code>type</code> variants as needed.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#101-output-requests","title":"10.1 Output requests","text":"<p>Output definitions live alongside the physical description so scenarios are self-documenting and reproducible. Two request flavours remain available:</p> <ul> <li>Field maps (<code>{\"type\":\"field_map\", \"id\":\"domain_field\", \"quantity\":\"BH\", \"path\":\"outputs/domain_bh.csv\"}</code>)   dump full-grid data. The CSV always starts with <code>x,y</code> and then includes   whichever columns match the requested quantity: <code>B</code> (<code>Bx,By,Bmag</code>), <code>H</code>   (<code>Hx,Hy,Hmag</code>), <code>BH</code> (both sets), or <code>energy_density</code> (both sets plus   <code>EnergyDensity</code>). Paths default to <code>outputs/&lt;id&gt;.csv</code> when omitted.</li> <li>Line probes (<code>{\"type\":\"line_probe\", \"axis\":\"x\", \"value\":0.0, \"quantity\":\"energy_density\"}</code>)   sample a horizontal or vertical line aligned with the grid. Specify <code>axis</code>   (<code>\"x\"</code> or <code>\"y\"</code>), the coordinate to lock, the field component (<code>Bx</code>, <code>By</code>,   <code>Bmag</code>, <code>Hx</code>, <code>Hy</code>, <code>Hmag</code>, or <code>energy_density</code>), and an output path. The   ingestor validates that the requested line lands on an existing grid column or   row.</li> <li>Mechanical traces (<code>{\"type\":\"mechanical_trace\", \"id\":\"pm_spinup\", \"rotors\":[\"pm_rotor\"]}</code>)   log rotor state samples after each solved frame. The CSV header is   <code>time_s,rotor,angle_deg,omega_rad_s,omega_rpm,torque_Nm</code>, making it easy to   validate spin-up behaviour or feed coupled ODE solvers during post-processing.</li> </ul> <p>Python authors can build these records via <code>scenario_api.FieldMapOutput</code>/<code>LineProbeOutput</code>. Downstream tooling such as <code>python/visualize_scenario_field.py</code> consumes the emitted CSV to produce quick look plots for scenario debugging.</p>"},{"location":"developer-guide/math-and-solver/fundamentals/#102-analytic-reference-counter-wound-wires","title":"10.2 Analytic reference: counter-wound wires","text":""},{"location":"developer-guide/math-and-solver/overview/","title":"Math &amp; Solver Overview","text":"<p>These notes summarise the magnetostatic formulation, discretisation, and timeline features used by the solver. Start with Fundamentals for governing equations, then continue to Back EMF and Time-Series for specialised workflows. Reusable equations and symbol tables live under Reference \u2192 Equations.</p>"},{"location":"developer-guide/math-and-solver/time-series/","title":"Time-Series Frames and Parallel Solving","text":"<p>The solver can execute quasi-static studies by expanding a scenario's <code>timeline</code> array into independent frames. Each frame is a snapshot of the problem with its own wire currents and magnetisation overrides. The solver rasterises and solves these frames sequentially by default, or concurrently when <code>--parallel-frames</code> is supplied. For an end-to-end walkthrough see the Running Simulations guide; this page focuses on schema details and developer diagnostics.</p>"},{"location":"developer-guide/math-and-solver/time-series/#authoring-a-timeline","title":"Authoring a Timeline","text":"<p>Add a <code>timeline</code> array to a scenario JSON file. Each entry is an object that can contain:</p> <ul> <li><code>t</code> or <code>time</code>: Optional timestamp stored for reference and reporting.</li> <li><code>wire_currents</code>: Array of absolute currents matching the order of the <code>sources</code>   list. Alternatively, provide a <code>wires</code> array with objects containing   <code>index</code> and either <code>current</code>, <code>I</code>, or <code>scale</code> (relative multiplier).</li> <li><code>rotor_angle</code> / <code>rotor_angle_deg</code>: Legacy shorthand that rotates the first   rotor when <code>rotors</code> are declared, or all magnet regions when no rotors exist.</li> <li><code>rotor_angles</code>: Fine-grained rotor overrides. Accepts either an array of   angles (aligned with the order of the <code>rotors</code> list), an array of objects with   <code>index</code>/<code>name</code> and <code>angle</code>/<code>angle_deg</code>, or an object mapping rotor names to   angles in degrees.</li> <li><code>magnets</code>: Array of per-region overrides, each with an <code>index</code> and either an   <code>angle_deg</code> rotation or a <code>magnetization</code> vector (<code>[Mx, My]</code> array or object   with <code>Mx</code>/<code>My</code>).</li> </ul>"},{"location":"developer-guide/math-and-solver/time-series/#rotor-definitions","title":"Rotor definitions","text":"<p>Declare rigid rotor groups in the root of the scenario JSON under <code>\"rotors\"</code>. Each entry can specify:</p> <ul> <li><code>name</code>: Optional identifier used by <code>rotor_angles</code> and metadata.</li> <li><code>pivot</code>: Two-element array <code>[x, y]</code> describing the rotation centre (defaults   to the domain origin if omitted).</li> <li><code>polygon_indices</code>: Zero-based indices into the polygon region list that   should rotate with the rotor.</li> <li><code>magnet_indices</code>: Magnet region indices that move and spin with the rotor.</li> <li><code>wire_indices</code>: Source indices (wires) that orbit the pivot.</li> </ul> <p>Polygons and magnets carry their geometry through the rotation, ensuring both field rasterisation and exported outlines match the transformed shape. Wires are repositioned before the solve so current deposition tracks the new location.</p> <p>Example:</p> <pre><code>\"timeline\": [\n  {\"t\": 0.0, \"wire_currents\": [10.0, -10.0]},\n  {\"t\": 0.001, \"wire_currents\": [5.0, -5.0], \"rotor_angles\": {\"rotor\": 90.0}},\n  {\n    \"t\": 0.002,\n    \"wires\": [{\"index\": 0, \"current\": 0.0}, {\"index\": 1, \"scale\": 0.25}],\n    \"magnets\": [{\"index\": 0, \"angle_deg\": 45.0}],\n    \"rotor_angles\": [{\"name\": \"aux_rotor\", \"angle_deg\": -15.0}]\n  }\n]\n</code></pre> <p>Each timeline entry produces a <code>ScenarioFrame</code> with its own copy of the base specification. The <code>expandScenarioTimeline</code> helper returns the expanded list of frames for use in tests and tooling.</p>"},{"location":"developer-guide/math-and-solver/time-series/#cli-usage","title":"CLI Usage","text":"<p>Run the solver across all frames with:</p> <pre><code>./build/motor_sim --scenario inputs/your_scenario.json --solve\n</code></pre> <p>When a timeline is present, outputs automatically gain a <code>_frame_XXX</code> suffix to avoid overwriting results. Enable multi-threaded solving with:</p> <pre><code>./build/motor_sim --scenario inputs/your_scenario.json --solve --parallel-frames\n</code></pre> <p>The solver launches up to <code>hardware_concurrency() - 1</code> worker threads, capped by the number of frames.</p>"},{"location":"developer-guide/math-and-solver/time-series/#warm-starts-and-prolongation","title":"Warm starts and prolongation","text":"<p>Timeline solves can reuse previous solutions to accelerate convergence. Passing <code>--warm-start</code> retains the final \\(A_z\\) field from the preceding frame and feeds it to the next CG call as the initial guess. For sudden changes (e.g., when switching from a coarse exploratory solve to a finer production grid), combine <code>--use-prolongation</code> with optional <code>--coarse-nx/--coarse-ny</code> overrides to seed the fine grid from a cheap coarse solve. These options materially reduce CG iteration counts while matching the SOR baseline to within the regression tolerances.</p>"},{"location":"developer-guide/math-and-solver/time-series/#output-naming","title":"Output Naming","text":"<p>For single-frame scenarios (no <code>timeline</code> key), output paths are respected as written. When a timeline is present, each field map, line probe, and midline CSV appends <code>_frame_###</code> (three digits by default) before the extension, e.g. <code>outputs/flux_map_frame_002.csv</code>.</p>"},{"location":"developer-guide/math-and-solver/time-series/#testing-support","title":"Testing Support","text":"<p><code>tests/timeline_frames_test.cpp</code> ensures timeline parsing, wire overrides, rotor-driven geometry motion, and magnet rotations behave predictably. The accompanying JSON fixture lives in <code>inputs/tests/timeline_frames_test.json</code>.</p>"},{"location":"reference/cli/","title":"Command-Line Interface","text":"<p>The <code>motor_sim</code> executable accepts the following high-level flags:</p> Flag Description <code>--scenario PATH</code> Load a scenario JSON file. Required for all solves. <code>--solve</code> Execute the magnetostatic solve after rasterising the scenario. <code>--solver {sor,cg}</code> Select the iterative solver (default: <code>cg</code>). <code>--tol VALUE</code> Relative residual tolerance (default: <code>1e-6</code>). <code>--max-iters N</code> Iteration limit for the selected solver. <code>--warm-start</code> Reuse the previous frame\u2019s solution as the initial guess. <code>--use-prolongation</code> Seed a fine grid from a coarse solve (pair with <code>--coarse-nx/--coarse-ny</code>). <code>--vtk-series PATH</code> Emit a ParaView <code>.pvd</code> time-series descriptor alongside per-frame <code>.vti</code> outputs. <code>--outputs LIST</code> Restrict emitted outputs by ID (<code>--outputs none</code> disables emission). <code>--list-outputs</code> Print the outputs declared by the scenario without solving. <code>--parallel-frames</code> Solve timeline frames concurrently (up to hardware concurrency minus one). <code>--progress-every SECONDS</code> Adjust progress reporting cadence. <code>--quiet</code> Suppress progress output. <code>--snapshot-every N</code> Request downsampled diagnostics every <code>N</code> iterations. <p>Run <code>./build/motor_sim --help</code> to inspect the complete flag list, including regression and development switches.</p>"},{"location":"reference/equations/","title":"Equation Reference","text":"<p>This section collects reusable notation and derived expressions shared across user and developer guides.</p>"},{"location":"reference/equations/#symbols","title":"Symbols","text":"Symbol Description \\(A_z\\) Out-of-plane component of the magnetic vector potential \\(\\mathbf{B}\\) Magnetic flux density \\((B_x, B_y, 0)\\) \\(\\mathbf{H}\\) Magnetic field intensity \\(\\mu_0\\) Vacuum permeability \\(\\mu_r\\) Relative permeability \\(\\mu = \\mu_0 \\mu_r\\) Absolute permeability \\(\\nu = 1/\\mu\\) Magnetic reluctivity \\(\\mathbf{M}\\) Magnetisation vector \\(J_z\\) Impressed current density along \\(z\\) \\(J_{m,z}\\) Magnetisation-induced bound current density <p>See Electromagnetics and Motor Models for derived identities grouped by topic.</p>"},{"location":"reference/equations/electromagnetics/","title":"Electromagnetics","text":""},{"location":"reference/equations/electromagnetics/#magnetostatic-formulation","title":"Magnetostatic formulation","text":"<p>The magnetostatic solve assumes a single non-zero vector potential component \\(A_z(x, y)\\). The governing PDE is</p> \\[ \\nabla \\cdot (\\nu \\nabla A_z) = -J_z, \\] <p>with \\(\\nu = 1/\\mu\\). For uniform materials the expression reduces to the familiar Poisson form</p> \\[ \\nabla^2 A_z = -\\mu J_z. \\]"},{"location":"reference/equations/electromagnetics/#magnetic-flux-density","title":"Magnetic flux density","text":"<p>Recovered field components follow from central differences of \\(A_z\\):</p> \\[ B_x \\approx \\frac{A_{i,j+1} - A_{i,j-1}}{2\\Delta y}, \\qquad B_y \\approx -\\frac{A_{i+1,j} - A_{i-1,j}}{2\\Delta x}. \\] <p>The magnetic field intensity combines the solved field with magnetisation contributions:</p> \\[ \\mathbf{H} = \\nu \\mathbf{B} - \\frac{1}{\\mu_r} \\mathbf{M}. \\]"},{"location":"reference/equations/electromagnetics/#magnetisation-sources","title":"Magnetisation sources","text":"<p>Permanent magnets appear as an equivalent bound current density</p> \\[ J_{m,z} = \\partial_x M_y - \\partial_y M_x, \\] <p>which is added to \\(J_z\\) during rasterisation.</p>"},{"location":"reference/equations/motor-models/","title":"Motor Models","text":"<p>These canonical relations summarise the quantities referenced across the machine scenario guides. All angles use electrical radians unless stated otherwise.</p>"},{"location":"reference/equations/motor-models/#three-phase-stator","title":"Three-phase stator","text":"<p>Balanced phase currents follow</p> \\[ i_a = I_{\\text{peak}} \\cos(\\omega t), \\quad i_b = I_{\\text{peak}} \\cos\\left(\\omega t - \\tfrac{2\\pi}{3}\\right), \\quad i_c = I_{\\text{peak}} \\cos\\left(\\omega t + \\tfrac{2\\pi}{3}\\right). \\] <p>The resulting rotating magnetomotive force can be approximated near the bore by</p> \\[ \\mathcal{F}(\\theta, t) \\approx \\tfrac{3}{2} N I_{\\text{peak}} \\cos(\\theta - \\omega t), \\] <p>where \\(N\\) is the number of turns per phase.</p>"},{"location":"reference/equations/motor-models/#back-emf-sampling","title":"Back-EMF sampling","text":"<p>When sampling induced voltage from a moving conductor the simulation reports</p> \\[ e(t) = -\\frac{d\\Phi(t)}{dt}, \\] <p>with \\(\\Phi(t)\\) obtained by integrating \\(B_n\\) over the winding cross-section. See Back EMF for implementation notes.</p>"},{"location":"reference/file-formats/scenario-json/","title":"Scenario JSON","text":"<p>Scenario files define geometry, materials, sources, and outputs for the solver. This stub highlights the most frequently used fields; consult the schema in <code>python/scenario_api.py</code> for exhaustive options.</p> Field Type Description <code>domain</code> object Simulation extents, grid resolution, and boundary conditions. <code>materials</code> array List of material definitions referenced by regions. <code>regions</code> array Geometry definitions (<code>polygon</code>, <code>halfspace</code>, etc.) with material assignments. <code>sources</code> array Current-carrying conductors with winding metadata. <code>magnets</code> array Permanent magnet regions with magnetisation vectors. <code>timeline</code> array Optional per-frame overrides for currents, magnet orientation, and rotor angles. <code>outputs</code> object Requested exports such as field maps, line probes, or VTK series. <code>rotors</code> array Rotor assemblies that group regions, magnets, and wires for rigid motion. <p>Additional helper fields (e.g., <code>phase_currents</code>, <code>transient</code>) are documented in the developer guide. Future revisions will expand this page with concrete JSON fragments and validation rules as the schema stabilises.</p>"},{"location":"reference/file-formats/vtk/","title":"VTK Output","text":"<p><code>motor_sim</code> writes VTK ImageData (<code>.vti</code>) for field maps and optional PolyData (<code>.vtp</code>) outlines.</p>"},{"location":"reference/file-formats/vtk/#image-data-vti","title":"Image data (<code>.vti</code>)","text":"Array Location Description <code>B</code> Cell data Magnetic flux density vector magnitude and components. <code>H</code> Cell data Magnetic field intensity derived from <code>B</code> and material properties. <code>J</code> Cell data Impressed current density (per frame). <code>region_index</code> Cell data Material region identifier used for visual overlays. <p>Open the sequence through the generated <code>.pvd</code> index when <code>--vtk-series</code> is passed on the CLI.</p>"},{"location":"reference/file-formats/vtk/#geometry-outlines-vtp","title":"Geometry outlines (<code>.vtp</code>)","text":"<p>PolyData outlines contain per-cell attributes for <code>kind</code>, <code>loop_index</code>, and optional rotor or stator labels. Join the accompanying <code>*_outlines_labels.csv</code> file in ParaView to expose human-readable names when colouring or filtering loops.</p> <p>For visualization workflows see Visualization Overview.</p>"},{"location":"user-guide/gui_flask/","title":"Web GUI (Flask)","text":"<p>The Flask-based GUI provides a lightweight browser front-end for running <code>mag_sim</code> scenarios. It mirrors the functionality explored in the Streamlit prototype while staying close to the underlying command-line workflow.</p>"},{"location":"user-guide/gui_flask/#requirements","title":"Requirements","text":"<ul> <li>A built <code>motor_sim</code> executable in <code>./build/motor_sim</code>.</li> <li>The devcontainer (or local virtual environment) must include Flask and its   lightweight companions. The repository's <code>.devcontainer/Dockerfile</code> installs   Flask, Flask-CORS, NumPy, Matplotlib, and <code>ezdxf</code> so the GUI has everything it   needs when launched inside Codespaces.</li> </ul>"},{"location":"user-guide/gui_flask/#starting-the-server","title":"Starting the server","text":"<p>From the repository root:</p> <pre><code>python -m python.gui.app_flask\n</code></pre> <p>The development server listens on <code>http://127.0.0.1:5000</code> by default. When running inside GitHub Codespaces or a similar environment, forward port 5000 to access the interface from your browser.</p> <p>Alternatively, set <code>FLASK_APP=python.gui.app_flask</code> and run <code>flask run</code> if you prefer Flask's CLI wrapper.</p>"},{"location":"user-guide/gui_flask/#using-the-interface","title":"Using the interface","text":"<ol> <li>Upload a scenario JSON file via the Scenario file input. (DXF uploads are    reserved for a future update and currently return a validation error.)</li> <li>Pick a solver (<code>cg</code> or <code>sor</code>), adjust the tolerance and maximum iteration    count if required, and optionally pass a value for <code>--outputs</code>.</li> <li>Click Run simulation. The form disables itself, the Stop button    becomes available, and a progress card appears.</li> <li>The server streams the solver's stdout via Server-Sent Events (SSE). The    progress bar reacts to any percentage tokens in the log, and the log panel    fills with the live output.</li> <li>When the run finishes, the log persists and a Downloads card appears with    links to the uploaded scenario and the captured log file. The log is useful    for sharing solver traces without leaving the browser.</li> <li>Click Run simulation again to process another scenario. Only one solve is    allowed at a time; the interface reports an error if you attempt to start a    second run before the first completes.</li> </ol> <p>Use the Stop button to request early termination. The server sends <code>terminate()</code> to the subprocess and the final log entry marks the stop request. Depending on solver state, expect a short delay while the child process exits.</p>"},{"location":"user-guide/gui_flask/#known-limitations","title":"Known limitations","text":"<ul> <li>DXF geometry ingestion is stubbed; use JSON scenarios generated via the   existing Python helpers until the converter is available.</li> <li>The progress parser uses a simple percentage heuristic. If the solver log does   not emit percentage tokens the bar will stay at 0\u202f% until the run completes.</li> <li>The current prototype keeps global state and targets single-user usage. A   production deployment should move to per-session queues and authentication.</li> </ul>"},{"location":"user-guide/gui_flask/#related-work","title":"Related work","text":"<p>A Streamlit-based GUI prototype lives on the <code>feat/gui-streamlit</code> branch. Both paths explore similar workflows; use this Flask version when you need explicit control over routing and templating, or switch branches to compare the Streamlit-powered experience.</p>"},{"location":"user-guide/running-simulations/","title":"Running Simulations","text":"<p>Follow this guide to execute bundled scenarios, manage timelines, and export outputs.</p>"},{"location":"user-guide/running-simulations/#1-generate-a-scenario","title":"1. Generate a scenario","text":"<p>Use the provided Python helpers to emit JSON inputs. For example, the three-phase stator generator produces both CI-sized and high-resolution variants:</p> <pre><code>python3 python/gen_three_phase_stator.py --profile ci --out inputs/three_phase_stator_ci.json\n</code></pre> <p>Switch to the high-resolution preset via <code>--profile hires</code>. Each profile controls grid resolution, frame count, and output cadence while keeping the downstream pipeline identical.</p>"},{"location":"user-guide/running-simulations/#2-solve-from-the-command-line","title":"2. Solve from the command line","text":"<pre><code>./build/motor_sim --scenario inputs/three_phase_stator_ci.json --solve --vtk-series outputs/three_phase_ci.pvd\n</code></pre> <p>Add <code>--parallel-frames</code> to solve timeline entries concurrently. Warm starts (<code>--warm-start</code>) reuse the previous frame\u2019s solution, typically halving CG iterations after the first frame. Prolongation (<code>--use-prolongation</code> with <code>--coarse-nx/--coarse-ny</code>) seeds fine grids from a coarse solve to accelerate convergence.</p> <p>Outputs inherit <code>_frame_###</code> suffixes when a <code>timeline</code> is present, avoiding collisions across frames.</p>"},{"location":"user-guide/running-simulations/#3-timeline-authoring","title":"3. Timeline authoring","text":"<p>Augment a scenario with a <code>timeline</code> array to prescribe per-frame changes:</p> <pre><code>\"timeline\": [\n  {\"t\": 0.0, \"wire_currents\": [10.0, -10.0]},\n  {\"t\": 0.001, \"wire_currents\": [5.0, -5.0], \"rotor_angles\": {\"rotor\": 90.0}},\n  {\n    \"t\": 0.002,\n    \"wires\": [{\"index\": 0, \"current\": 0.0}, {\"index\": 1, \"scale\": 0.25}],\n    \"magnets\": [{\"index\": 0, \"angle_deg\": 45.0}],\n    \"rotor_angles\": [{\"name\": \"aux_rotor\", \"angle_deg\": -15.0}]\n  }\n]\n</code></pre> <p>Each entry expands into an independent frame. Declare rotors under the top-level <code>rotors</code> key to group polygons, magnets, and wires that move together. Magnet overrides accept either rotation angles or explicit magnetisation vectors.</p>"},{"location":"user-guide/running-simulations/#4-inspecting-results","title":"4. Inspecting results","text":"<p>Open the emitted <code>.pvd</code> series in ParaView to explore fields and outlines. The generator emits:</p> <ul> <li><code>outputs/three_phase_frame_###.vti</code>: cell-centred B/H fields per frame.</li> <li><code>outputs/three_phase_ci.pvd</code>: ParaView time-series index (from <code>--vtk-series</code>).</li> <li><code>outputs/three_phase_outlines.vtp</code>: geometry overlays for slots, stator surfaces, and wires.</li> <li><code>outputs/bore_angle.csv</code>: bore-average flux magnitude and angle traces.</li> </ul> <p>Use <code>python/animate_three_phase.py</code> to create annotated animations, or the <code>python/visualize_scenario_field.py</code> helper for static renders with streamlines and overlays.</p> <p>Open in GUI</p>"},{"location":"user-guide/torque-and-forces/","title":"Force and Torque Probes","text":"<p>Magnetic machines often require estimates of the mechanical force or torque that the air-gap fields apply to a rotor. <code>mag_sim</code> now exposes a stress tensor probe that integrates the Maxwell stress tensor along a closed contour, giving per-unit-length force and torque values directly from the solved field map.</p>"},{"location":"user-guide/torque-and-forces/#maxwell-stress-tensor-refresher","title":"Maxwell Stress Tensor refresher","text":"<p>For magnetostatics the Maxwell stress tensor in Cartesian coordinates is</p> \\[ T_{ij} = \\frac{1}{\\mu_0} \\left(B_i B_j - \\tfrac{1}{2} \\delta_{ij} B^2\\right), \\] <p>with the traction on a surface of unit normal n given by</p> \\[ \\mathbf{f} = T \\cdot \\hat{\\mathbf{n}}. \\] <p>Integrating the traction around a closed 2D loop yields the net force per unit length, while the torque about the out-of-plane axis follows from</p> \\[ \\tau_z = \\oint (x f_y - y f_x)\\,\\mathrm{d}s. \\] <p>The solver evaluates these expressions numerically using midpoint sampling on polygon edges. Bilinear interpolation recovers B at arbitrary contour points so probes are not restricted to grid-aligned loops.</p>"},{"location":"user-guide/torque-and-forces/#json-schema","title":"JSON schema","text":"<p>Declare probes inside the scenario <code>outputs</code> array:</p> <pre><code>{\n  \"type\": \"probe\",\n  \"id\": \"rotor_mst\",\n  \"probe_type\": \"force_and_torque\",\n  \"method\": \"stress_tensor\",\n  \"loop\": {\n    \"type\": \"polygon\",\n    \"vertices\": [\n      [-0.03, -0.02],\n      [0.03, -0.02],\n      [0.03, 0.02],\n      [-0.03, 0.02]\n    ]\n  },\n  \"path\": \"outputs/rotor_mst.csv\"\n}\n</code></pre> <ul> <li><code>probe_type</code> chooses which quantities are of interest: <code>\"force\"</code>,   <code>\"torque\"</code>, or <code>\"force_and_torque\"</code> (all three values are written either way).</li> <li><code>method</code> currently supports only <code>\"stress_tensor\"</code>.</li> <li><code>loop</code> supplies at least three vertices describing the closed contour. Provide   either an array of <code>[x, y]</code> pairs or an object with <code>type=\"polygon\"</code> and a   <code>vertices</code> array as shown above.</li> </ul> <p>The solver writes a CSV with a single row:</p> <pre><code>Fx,Fy,Tz,CoEnergy\n-1.234567890123e+02,5.678901234567e+01,-2.468013579240e-03,1.234500000000e-01\n</code></pre> <p>Values represent force (newtons per metre) and torque (newton-metres per metre) about the global origin in SI units. The optional <code>CoEnergy</code> column captures the magnetic co-energy integral for the entire slice, enabling finite-difference virtual-work checks without recomputing the field.</p> <p>When timelines are active the solver still emits per-frame CSVs with the <code>_frame_###</code> suffix for detailed inspection, but it also aggregates the samples into the requested base path (for example <code>outputs/dc_motor_torque.csv</code>). The timeline CSV adds <code>time_s</code> and <code>frame_index</code> columns ahead of the stress tensor values so downstream scripts can correlate torque with the simulation clock.</p>"},{"location":"user-guide/torque-and-forces/#usage-tips","title":"Usage tips","text":"<ul> <li>Keep probe contours well inside the simulation domain so bilinear   interpolation never samples outside the grid.</li> <li>Dense grids yield smoother estimates. For coarse meshes consider slightly   inflating the loop to avoid sampling immediately adjacent to discretisation   artefacts.</li> <li>Combine with timeline frames to capture torque ripple across electrical angles   or to cross-check against virtual-work calculations using the magnetic   co-energy helper described below.</li> </ul>"},{"location":"user-guide/torque-and-forces/#virtual-work-cross-check","title":"Virtual-work cross-check","text":"<p>The solver now exposes <code>motorsim::compute_magnetic_coenergy</code>, which evaluates the magnetic co-energy (including permanent-magnet contributions),</p> \\[ W_m = \\tfrac{1}{2}\\int_{A} \\mathbf{B} \\cdot (\\mathbf{H} + \\mathbf{M}) \\, \\mathrm{d}A, \\] <p>over the 2D slice. When magnetisation is zero this reduces to the familiar \\(\\tfrac{1}{2}\\int \\mathbf{B}\\cdot\\mathbf{H}\\,\\mathrm{d}A\\). Combined with timeline frames at neighbouring rotor angles the virtual-work estimate follows directly from a finite difference,</p> \\[ \\tau_z \\approx \\frac{W_m(\\theta + \\Delta\\theta) - W_m(\\theta - \\Delta\\theta)}{2\\,\\Delta\\theta}. \\] <p><code>tests/torque_validation_test.cpp</code> exercises the full pipeline by solving the rotor dipole scenario at \u00b15\u00b0 offsets, evaluating both the Maxwell stress torque and the co-energy difference, and enforcing a \u226410\u202f% agreement on the CI grid. Any probe requesting torque automatically triggers <code>computeH()</code> and records the co-energy alongside the stress-tensor integral, making the diagnostic available for future report/CSV exports and the three-phase PM motor walkthrough.</p> <p>The <code>tests/probe_output_test.cpp</code> fixture exercises the ingestion and evaluation path with a synthetic field that generates a known downward force, providing a regression guard for the new feature.</p> <p>Open in GUI</p>"},{"location":"user-guide/machines/dc-commutated/","title":"DC motor with commutated armature","text":"<p>This scenario family complements the three-phase demos with a brushed DC motor that exercises the new commutator primitives. The generator lives in <code>python/gen_dc_motor.py</code> and emits both regression-sized fixtures and larger profiles suitable for ParaView walkthroughs.</p>"},{"location":"user-guide/machines/dc-commutated/#generator-overview","title":"Generator overview","text":"<pre><code>python3 python/gen_dc_motor.py --profile ci --mode spinup --out inputs/dc_motor_spinup_ci.json\npython3 python/gen_dc_motor.py --profile hires --mode spinup --out inputs/dc_motor_spinup_hires.json\npython3 python/gen_dc_motor.py --profile ci --mode commutator_test --out inputs/tests/dc_commutator_test.json\n</code></pre> <p>Profiles follow the established CI/hires split. The <code>ci</code> configuration keeps the mesh at 65\u00d765, limits circular tessellation to 24\u201348 vertices, and rounds all floating-point coordinates to three decimals so JSON fixtures stay readable. The <code>hires</code> preset scales those counts for offline studies.</p> <p><code>mode</code> selects the timeline wiring:</p> <ul> <li><code>spinup</code> \u2013 enables the RK4 mechanical simulator, runs a few dozen frames of   torque-driven acceleration, and emits VTK, torque, and mechanical traces.   The CI profile now stops after two electrical cycles (24 frames) so the   regression rotor history remains strictly increasing; the hires preset keeps   the longer six-cycle spin-up for offline inspection.</li> <li><code>locked</code> \u2013 leaves the rotor at its initial angle. Handy for debugging static   field maps or exporting outlines for documentation.</li> <li><code>commutator_test</code> \u2013 generates a four-frame timeline with scripted rotor angles   that the regression harness uses to validate the orientation switching logic.   The armature inductor starts at 8\u202fA so the deposited currents make the sign   flips obvious.</li> </ul>"},{"location":"user-guide/machines/dc-commutated/#geometry-and-materials","title":"Geometry and materials","text":"<ul> <li>Stator yoke: steel ring (<code>\u03bc\u1d63 \u2248 1800</code>) with bore radius 20\u202fmm.</li> <li>Rotor core: laminated steel disk (<code>\u03bc\u1d63 \u2248 1200</code>) centred on the origin and   attached to the <code>dc_rotor</code> mechanical entry.</li> <li>Field coils: two slot polygons at \u00b190\u00b0 with 220 turns each, a 0.58 fill   fraction, and default orientation of +1 (north pole) and \u22121 (south pole).</li> <li>Armature coil: two slots at 0\u00b0 and 180\u00b0 with 110 turns each, 0.52 fill, and   base orientations +1 and \u22121 so the return path flows correctly.</li> </ul> <p>The field and armature ampere-turns were tuned so the stator and rotor fields live in the same 0.01\u20130.08\u202fT envelope. The field circuit runs from 18\u202fV through 1.6\u202f\u03a9/80\u202fmH; the armature is driven by 12\u202fV through 0.75\u202f\u03a9/32\u202fmH. Both circuits are defined in the same MNA network (<code>dc_drive</code>).</p>"},{"location":"user-guide/machines/dc-commutated/#commutator-schema","title":"Commutator schema","text":"<p>Each <code>coil_link</code> may now carry a <code>commutator</code> block:</p> <pre><code>{\n  \"type\": \"coil_link\",\n  \"inductor\": \"arm_L\",\n  \"region\": \"armature_a\",\n  \"turns\": 110.0,\n  \"commutator\": {\n    \"rotor\": \"dc_rotor\",\n    \"default_orientation\": 1.0,\n    \"segments\": [\n      {\"start_deg\": -90.0, \"end_deg\": 90.0, \"orientation\": 1.0},\n      {\"start_deg\": 90.0, \"end_deg\": 270.0, \"orientation\": -1.0}\n    ]\n  }\n}\n</code></pre> <p>The solver normalises the rotor angle, picks the segment whose range contains that angle (wrapping across \u00b1180\u00b0 as needed), and multiplies the region\u2019s base orientation by the selected <code>orientation</code> factor. The <code>default_orientation</code> value applies if no segment matches (for example when the rotor is exactly on a boundary). The orientation update happens before each frame solve so both the current deposition and flux linkage integrals respect the commutator state.</p>"},{"location":"user-guide/machines/dc-commutated/#regression-coverage","title":"Regression coverage","text":"<ul> <li><code>tests/dc_commutator_test.cpp</code> loads the <code>commutator_test</code> fixture, advances   through the scripted angles, and asserts that the armature region orientations   switch signs at \u00b190\u00b0 exactly as the JSON specifies. The harness now checks   that both polarities occur and that at least one sign transition happens, so   the commutator crossing is exercised explicitly.</li> <li><code>tests/dc_motor_spinup_test.cpp</code> reuses the spin-up scenario, performs full CG   solves with torque probes, and requires \u22658\u00b0 of electrical rotation and \u22655\u202frad/s   of speed gain.</li> </ul> <p>Both binaries are wired into CTest, <code>scripts/run_ci_checks.sh</code>, and the GitHub Actions workflow.</p>"},{"location":"user-guide/machines/dc-commutated/#ci-demo","title":"CI demo","text":"<p><code>run_ci_checks.sh</code> and <code>.github/workflows/ci.yml</code> regenerate a fresh <code>inputs/dc_motor_spinup_ci.json</code>, solve it, validate the mechanical trace with <code>python/check_pm_spinup.py --rotor dc_rotor</code>, and archive the VTK series, mechanical CSV, the aggregated torque CSV, and outlines. The torque file now lists <code>time_s,frame_index,Fx,Fy,Tz[,CoEnergy]</code> so the commutator waveforms can be plotted directly against the timeline. The solver also emits <code>dc_motor_currents.csv</code> (the <code>circuit_trace</code> output) so <code>python/generate_rotor_animation.py</code> can render a rotor-only GIF/PNG alongside the field-mapped ParaView sequence. The brushed DC demo therefore ships with the same artefact set as the synchronous and induction motors.</p>"},{"location":"user-guide/machines/dc-commutated/#tuning-notes","title":"Tuning notes","text":"<ul> <li>Adjust the field/armature balance by changing the turn counts and resistances   in <code>DEFAULT_PROFILES</code>. Because current regions record turn counts, the circuit   parser enforces consistency across coil links.</li> <li><code>commutator_test</code> keeps only four frames so the regression JSON stays compact;   you can expand the <code>angles</code> list in the generator if you want additional   validation positions.</li> <li>The mechanical defaults (0.65\u00d710\u207b\u00b3\u202fkg\u00b7m\u00b2 inertia, 0.08\u202fN\u00b7m load) produce a   gentle spin-up in CI. Increase the load torque or damping to explore steady   states, or drop them to showcase faster acceleration in the hires profile.</li> </ul> <p>Open in GUI</p>"},{"location":"user-guide/machines/induction/","title":"Three-Phase Induction Motor Spin-Up","text":"<p>This demo extends the synchronous PM workflow to the transient, conductive case. It drives a three-phase stator with prescribed sinusoidal currents, solves the magneto-quasistatic system with the semi-implicit Crank\u2013Nicolson wrapper, and lets a squirrel-cage-style rotor accelerate under the resulting torque. Use it to sanity-check eddy-current torque production, slip behaviour, and the interaction between the transient field solve and the RK4 mechanical integrator.</p>"},{"location":"user-guide/machines/induction/#quickstart","title":"Quickstart","text":"<pre><code>python3 python/gen_three_phase_induction_motor.py --profile ci --mode spinup \\\n  --out inputs/three_phase_induction_motor_spinup_ci.json\n./build/motor_sim --scenario inputs/three_phase_induction_motor_spinup_ci.json \\\n  --solve --vtk-series outputs/induction_motor_spinup_ci.pvd --solver cg \\\n  --tol 5e-6 --max-iters 40000\npython3 python/check_pm_spinup.py --mechanical outputs/induction_motor_mechanical.csv \\\n  --scenario inputs/three_phase_induction_motor_spinup_ci.json \\\n  --rotor induction_rotor --min-angle-rise 6 --min-speed-rise 6\npython3 python/animate_three_phase.py --pvd outputs/induction_motor_spinup_ci.pvd \\\n  --scenario inputs/three_phase_induction_motor_spinup_ci.json \\\n  --save induction_motor_spinup.mp4 --frame-png induction_motor_spinup.png\n</code></pre> <p>Unlike the PM walkthrough there are no magnets or rotor circuit links. All rotor torque comes from induced currents in the conductive bars, so the transient solver must stay enabled and the mechanical integrator consumes the torque probe output every frame.</p>"},{"location":"user-guide/machines/induction/#profiles","title":"Profiles","text":"<p><code>python/gen_three_phase_induction_motor.py</code> ships with the familiar <code>ci</code> and <code>hires</code> presets:</p> <ul> <li><code>ci</code>: 65\u00d765 grid, 12 frames per electrical cycle, three cycles (36 frames)</li> <li><code>hires</code>: 401\u00d7401 grid, 180 frames per cycle, six cycles (1080 frames)</li> </ul> <p>Both support <code>--cycles</code> and <code>--frames-per-cycle</code> overrides. The CI profile keeps the geometry lightweight\u2014circles are tessellated with 24\u201330 points (24 for the stator, 18 for the bore, 14 for the rotor, 30 for the torque loop) and coordinates are rounded to four decimal places\u2014so fixtures remain reviewable.</p> <p>The generator also exposes <code>--mode locked</code> if you want a deterministic rotor pose for debugging; the spin-up regression omits rotor overrides so the mechanical simulator evolves the angle based on torque feedback.</p>"},{"location":"user-guide/machines/induction/#scenario-highlights","title":"Scenario highlights","text":"<ul> <li>Rotor cage \u2013 The rotor combines a high-\u00b5 iron core with six conductive   bars (\u03c3\u22481.8\u00d710\u2077\u202fS/m) and a modest core conductivity (\u03c3\u22485\u00d710\u2075\u202fS/m) so eddy   currents can circulate. All rotor polygons are grouped under the named rotor   <code>induction_rotor</code>, letting the mechanical simulator rotate the cage as a rigid   body.</li> <li>Transient solve \u2013 The top-level <code>\"transient\"</code> block requests the   Crank\u2013Nicolson wrapper with a timestep equal to one frame spacing. Each frame   stores the previous vector potential so the solver can apply the   \\(\\sigma/\\Delta t\\) mass term and march the field forward without rebuilding   matrices.</li> <li>Phase drives \u2013 Current regions still carry phase labels, turn counts (50   per slot by default), and a 0.55 fill fraction. The generator emits per-frame   <code>\"phase_currents\"</code> overrides rather than circuits, so the stator ampere-turns   follow the 42\u202fA peak sinusoids directly.</li> <li>Mechanical trace \u2013 The <code>mechanical</code> section provides inertia, damping,   load torque, and ties the rotor to the torque probe. CI captures   <code>outputs/induction_motor_mechanical.csv</code>, and <code>python/check_pm_spinup.py</code>   measures absolute angle/speed growth so it can validate the trace with   <code>--rotor induction_rotor</code> even though the rotor spins negative relative to the   stator field.</li> <li>Outputs \u2013 VTK series, outline polydata, bore-field CSVs, three back-EMF   probes (one per positive slot), and the mechanical trace mirror the PM demo so   ParaView workflows stay familiar. The torque probe aggregates its timeline to   <code>induction_motor_torque.csv</code> (with <code>time_s,frame_index,Fx,Fy,Tz[,CoEnergy]</code>) so   slip and torque comparisons are easy to chart without collecting each   <code>_frame_###</code> file manually.</li> </ul>"},{"location":"user-guide/machines/induction/#regression-fixture","title":"Regression fixture","text":"<p>The CI test <code>tests/induction_spinup_test.cpp</code> exercises the lightweight regression stored at <code>inputs/tests/induction_spinup_test.json</code>, generated via:</p> <pre><code>python3 python/gen_three_phase_induction_motor.py --profile ci --mode spinup \\\n  --out inputs/tests/induction_spinup_test.json\n</code></pre> <p>Key baked-in values:</p> Quantity Value Grid 65\u00d765 Cartesian cells over a 0.14 m square Electrical frequency 60 Hz (12 frames per cycle, 3 cycles) Rotor inertia / damping 1.1\u00d710\u207b\u00b3 kg\u00b7m\u00b2, 8.0\u00d710\u207b\u2075 N\u00b7m\u00b7s Load torque 0.08 N\u00b7m opposing rotation Slot turns / fill 50 turns per slot, 0.55 copper fill fraction Rotor bars Six wedges with \u03c3=1.8\u00d710\u2077\u202fS/m (core \u03c3=5.0\u00d710\u2075\u202fS/m) Phase drive 42 A peak prescribed sinusoids <p>The regression loop calls <code>solveTransientStep</code> each frame, computes Maxwell stress torque, and advances the mechanical simulator. It asserts a positive angle and speed rise, checks the rotor remains at least 20% below synchronous speed (2\u03c0\u00b760 rad/s for the two-pole equivalent), and prints the slip for the accuracy report. CI also renders the VTK series, outline polydata, and animated field plots alongside the existing stator and PM motor artefacts.</p>"},{"location":"user-guide/machines/induction/#tips","title":"Tips","text":"<ul> <li>Keep the transient timestep aligned with the electrical frequency so the slip   stays stable; extremely coarse \u0394t will overdamp the CN step.</li> <li>Use <code>--mode locked</code> together with a short timeline when debugging geometry or   torque probes\u2014this preserves the rotor pose while you focus on field snapshots.</li> <li>The induction scenario currently drives phase currents directly. To co-simulate   an RL network, extend the generator with the same <code>circuits</code> schema used in the   synchronous PM workflow and feed the induced back-EMF into the voltage sources.</li> <li>Pair the torque CSV with the mechanical trace to estimate instantaneous slip   and steady-state torque. The back-EMF probes provide an easy sanity check that   induced voltages lag the stator currents as expected for an induction machine.</li> </ul> <p>Open in GUI</p>"},{"location":"user-guide/machines/pm-synchronous/","title":"Three-Phase PM Motor Scenario","text":"<p>This walkthrough builds on the rotating-field stator demo by adding a   surface-mounted permanent-magnet rotor (trimmed to 1\u00d710\u2075\u202fA/m with \u03bc\u1d63\u22481.05),   per-phase RL circuits, and a lightweight mechanical model driven by 35\u202fA peak stator currents. Use it to explore torque production, back-EMF, and circuit response in a synchronous motor setting. The generator now supports both a locked-rotor mode (matching earlier releases) and a spin-up mode that lets the mechanical integrator advance the rotor angle from the electromagnetic torque.</p>"},{"location":"user-guide/machines/pm-synchronous/#quickstart-locked-rotor","title":"Quickstart (locked rotor)","text":"<pre><code>python3 python/gen_three_phase_pm_motor.py --profile ci --mode locked --out inputs/three_phase_pm_motor_ci.json\n./build/motor_sim --scenario inputs/three_phase_pm_motor_ci.json --solve --vtk-series outputs/pm_motor_ci.pvd --tol 5e-6 --max-iters 40000\npython3 python/animate_three_phase.py --pvd outputs/pm_motor_ci.pvd --scenario inputs/three_phase_pm_motor_ci.json --save pm_motor_demo.mp4 --frame-png pm_motor_demo.png\n</code></pre> <p>The locked mode emits the same deterministic timeline used in earlier demos: it drives sinusoidal phase voltages, integrates coil currents via the circuit solver, and keeps the rotor phased to the stator field via explicit <code>rotor_angles</code> entries.</p>"},{"location":"user-guide/machines/pm-synchronous/#spin-up-mode","title":"Spin-up mode","text":"<pre><code>python3 python/gen_three_phase_pm_motor.py --profile ci --mode spinup --out inputs/three_phase_pm_motor_spinup_ci.json\n./build/motor_sim --scenario inputs/three_phase_pm_motor_spinup_ci.json --solve --vtk-series outputs/pm_motor_spinup_ci.pvd --tol 5e-6 --max-iters 40000\npython3 python/check_pm_spinup.py --mechanical outputs/pm_motor_spinup_mechanical.csv --scenario inputs/three_phase_pm_motor_spinup_ci.json\npython3 python/animate_three_phase.py --pvd outputs/pm_motor_spinup_ci.pvd --scenario inputs/three_phase_pm_motor_spinup_ci.json --save pm_motor_spinup.mp4 --frame-png pm_motor_spinup.png\n</code></pre> <p>Spin-up removes the timeline rotor overrides so the RK4 mechanical integrator advances the rotor based on the torque probe feedback. The generator also emits <code>pm_motor_spinup_mechanical.csv</code>, a rotor angle/speed log that the <code>python/check_pm_spinup.py</code> helper validates for monotonic acceleration.</p>"},{"location":"user-guide/machines/pm-synchronous/#profiles","title":"Profiles","text":"<p><code>python/gen_three_phase_pm_motor.py</code> exposes the same <code>ci</code> and <code>hires</code> presets as the stator generator. Use <code>--mode locked</code> (default) for the deterministic rotor timeline or <code>--mode spinup</code> to enable mechanical integration. All profiles accept <code>--cycles</code> and <code>--frames-per-cycle</code> overrides when you need shorter or longer timelines:</p> <ul> <li><code>ci</code>: 65\u00d765 grid, 12 frames (one electrical cycle)</li> <li><code>hires</code>: 401\u00d7401 grid, 120 frames per cycle, three electrical cycles</li> </ul> <p>Pass <code>--profile hires</code> to emit the larger dataset. All downstream commands stay the same.</p>"},{"location":"user-guide/machines/pm-synchronous/#scenario-highlights","title":"Scenario highlights","text":"<ul> <li>Rotor assembly \u2013 A rigid body named <code>pm_rotor</code> groups the rotor iron   polygon and the rectangular magnet block. The generator also carves the magnet   out of the rotor iron and assigns it the <code>pm_magnet</code> material (\u03bc\u1d63\u22481.05) so the   magnetisation vector does not experience an 800\u00d7 permeability boost. Locked mode includes   <code>\"rotor_angles\"</code> timeline entries to phase-lock the magnet to the rotating   stator field by a configurable load angle, while spin-up mode omits them so   the mechanical integrator owns the pose.</li> <li>Circuits \u2013 The <code>stator_three_phase</code> network models each phase as a series   <code>R-L</code> branch with a driven voltage source. Coil links bind both slot polygons   for a phase to the shared inductor so the circuit solver injects equal and   opposite current densities. The ingestor now enforces that each coil link\u2019s   turn count matches the associated <code>current_region</code>, keeping the magnetic   ampere-turn budget consistent between the field solve and the circuit model.</li> <li>Slot packing \u2013 Slot polygons carry 60 turns apiece with a 0.55 fill   fraction. The rasteriser multiplies the timeline or circuit current by both   factors so the resulting ampere-turn budget matches what the circuit solver   assumes when computing coil flux linkages.</li> <li>Bore field levels \u2013 The pm-magnet material keeps |B| in the rotor block on   roughly the same sub-tesla scale as the driven stator coils rather than the   50\u2013200\u202fT range seen when the magnet inherited the 800\u00d7 permeability of the   surrounding steel. This makes the torque interaction easier to inspect and   maintains a realistic magnitude for induced voltages.</li> <li>Mechanical coupling \u2013 The <code>mechanical</code> section specifies rotor inertia,   viscous damping, constant load torque, and the torque probe that feeds the   integrator. Spin-up mode keeps the timeline free of overrides so the solver   performs an RK4 update after each frame to evolve angle and speed.</li> <li>Probes \u2013 Back-EMF loops measure the induced voltage inside every positive   slot, while the torque probe wraps a circular loop just outside the rotor to   collect Maxwell stress and co-energy samples.</li> </ul>"},{"location":"user-guide/machines/pm-synchronous/#outputs","title":"Outputs","text":"<ul> <li>Locked mode uses the <code>pm_motor_*.csv/.vti/.pvd</code> naming scheme. Spin-up mode   mirrors the same exports with a <code>pm_motor_spinup_*</code> prefix and adds   <code>pm_motor_spinup_mechanical.csv</code> capturing time, angle, speed, and torque for   each rotor sample.</li> <li>Torque CSVs now aggregate timeline samples at the base path (for example   <code>pm_motor_spinup_torque.csv</code>). Each row records <code>time_s,frame_index,Fx,Fy,Tz</code>   and, when available, <code>CoEnergy</code>, so finite-difference virtual-work checks can   be run directly against the solved timeline without chasing individual   <code>_frame_###</code> files.</li> <li>Both modes emit a <code>circuit_trace</code> CSV (<code>pm_motor_currents.csv</code> or   <code>pm_motor_spinup_currents.csv</code>) listing per-coil ampere-turn histories. The   file feeds the <code>python/generate_rotor_animation.py</code> helper so slot colours in   the rotor-only GIFs reflect the solved coil currents.</li> </ul>"},{"location":"user-guide/machines/pm-synchronous/#ci-spin-up-fixture-at-a-glance","title":"CI spin-up fixture at a glance","text":"<p>The regression stored at <code>inputs/tests/pm_motor_spinup_test.json</code> is generated verbatim from:</p> <pre><code>python3 python/gen_three_phase_pm_motor.py --profile ci --mode spinup \\\n  --out inputs/tests/pm_motor_spinup_test.json\n</code></pre> <p>The JSON clocks in at roughly 1.3k lines\u2014the generator rounds coordinates to three decimal places for the CI profile and keeps each circular boundary to a few dozen segments (18 for the stator, 12 for the bore, 10 for the rotor, 24 for the torque loop). The timeline spans a single electrical cycle (10 frames) so the mechanical solver still sees enough motion to verify acceleration. Key baked-in values for the CI fixture are:</p> Quantity Value Grid 65\u00d765 Cartesian cells over a 0.14 m square Electrical frequency 60 Hz (10 frames per cycle, 1 cycle) Rotor inertia / damping 8.0\u00d710\u207b\u2074 kg\u00b7m\u00b2, 5.0\u00d710\u207b\u2075 N\u00b7m\u00b7s Load torque 0.12 N\u00b7m opposing rotation Magnet strength 1\u00d710\u2075 A/m surface-mounted block Slot turns / fill 60 turns per slot, 0.55 copper fill fraction Phase drive 35 A peak warm-start currents with 20 V peak phase voltage <p>Rather than editing the JSON manually, re-run the generator when you need to tweak those knobs so the derived polygons stay consistent.</p>"},{"location":"user-guide/machines/pm-synchronous/#faster-local-experiments","title":"Faster local experiments","text":"<p>The bundled test still takes roughly a minute on two vCPUs so the torque and mechanical traces match the CI artefacts while remaining tractable. For day-to-day iteration you can emit smaller timelines without touching the committed fixture. A few useful variants:</p> <pre><code># Half a cycle on the CI grid (6 frames) for quick smoke checks\npython3 python/gen_three_phase_pm_motor.py --profile ci --mode spinup \\\n  --frames-per-cycle 6 --cycles 1 --out scratch/spinup_quick.json\n\n# Coarser mechanical sampling on a reduced grid\npython3 python/gen_three_phase_pm_motor.py --profile ci --mode spinup \\\n  --cycles 1 --frames-per-cycle 8 --out scratch/spinup_57.json\n\n# Re-run only the spin-up regression once you have a new fixture\nctest --test-dir build --output-on-failure -R pm_motor_spinup\n</code></pre> <p>Keep the official regression JSON in place so GitHub Actions exercises the full solve, but feel free to adjust the generator overrides locally when validating mechanical changes or iterating on torque probes.</p>"},{"location":"user-guide/machines/pm-synchronous/#tips","title":"Tips","text":"<ul> <li>Run <code>python/check_three_phase_field.py</code> against the generated <code>.pvd</code> to verify   the bore angle rotates monotonically and maintains a strong |B| magnitude.</li> <li>Use <code>python/check_pm_spinup.py</code> on spin-up runs to assert that rotor angle and   speed change monotonically in magnitude throughout the timeline (the helper   reports absolute angle/speed gains, so it also tolerates rotors that spin in   the negative direction as in the induction demo).</li> <li>The mechanical integrator respects timeline rotor overrides; locked mode   retains them while spin-up drops them so the solver can demonstrate the coupled   evolution.</li> <li>Pair the torque CSV with the co-energy column to compute finite-difference   virtual-work torque checks over neighbouring frames.</li> <li>Keep generated VTK/MP4 artefacts out of the repository. CI uploads small   samples for review when the workflow executes the PM motor pipeline.</li> <li>Looking for a transient induction counterpart? See   <code>docs/three_phase_induction_motor.md</code> for the conductive-bar spin-up workflow.</li> </ul> <p>Open in GUI</p>"},{"location":"user-guide/machines/three-phase-stator/","title":"Three-Phase Stator Scenario","text":"<p>This scenario bundles a six-slot, two-pole three-phase stator that drives a balanced rotating field. The Python generator produces both the tiny CI-sized case and a high-resolution configuration by tweaking a single profile flag.</p>"},{"location":"user-guide/machines/three-phase-stator/#quickstart","title":"Quickstart","text":"<pre><code>python3 python/gen_three_phase_stator.py --profile ci --out inputs/three_phase_stator_ci.json\n./build/motor_sim --scenario inputs/three_phase_stator_ci.json --solve --parallel-frames --vtk-series outputs/three_phase_ci.pvd --tol 5e-6 --max-iters 40000\npython3 python/animate_three_phase.py --pvd outputs/three_phase_ci.pvd --scenario inputs/three_phase_stator_ci.json --save three_phase_demo.mp4 --frame-png three_phase_demo.png\n</code></pre> <p>The generated scenario exports cell-centred VTK frames, a bore-average CSV, and polyline outlines that highlight the stator geometry.</p>"},{"location":"user-guide/machines/three-phase-stator/#scaling-up","title":"Scaling up","text":"<p>The generator exposes two profiles:</p> <ul> <li><code>ci</code>: 65\u00d765 grid, 12 frames (one electrical cycle)</li> <li><code>hires</code>: 401\u00d7401 grid, 120 frames per cycle, three electrical cycles</li> </ul> <p>Switch profiles via <code>--profile hires</code> to emit the high-resolution configuration. All other pipeline steps remain unchanged\u2014simply re-run <code>motor_sim</code> and the animation command on the new JSON.</p>"},{"location":"user-guide/machines/three-phase-stator/#outputs","title":"Outputs","text":"<ul> <li><code>outputs/three_phase_frame_###.vti</code>: per-frame cell-centred B/H fields.</li> <li><code>outputs/three_phase_ci.pvd</code>: ParaView time-series index (generated via   <code>--vtk-series</code>).</li> <li><code>outputs/three_phase_outlines.vtp</code>: geometry polylines for overlaying slot   and stator boundaries.</li> <li><code>outputs/bore_angle.csv</code>: bore-average B components, magnitudes, and angles.</li> </ul>"},{"location":"user-guide/machines/three-phase-stator/#paraview-tips","title":"ParaView tips","text":"<ol> <li>Open the <code>.pvd</code> series to load the time-resolved field data.</li> <li>Add <code>three_phase_outlines.vtp</code> as a separate source and enable it in the    pipeline to overlay slot and stator geometry.</li> <li>Use the \u201cGlyph\u201d filter on <code>three_phase_outlines.vtp</code> for quick directional    cues, or switch the VTI representation to \u201cSurface LIC\u201d for streamline-like    visuals.</li> </ol>"},{"location":"user-guide/machines/three-phase-stator/#animation","title":"Animation","text":"<p><code>python/animate_three_phase.py</code> renders a full-field animation that overlays the cell-centred |B| map, quiver arrows, bore compass, labelled slot outlines, and the driving phase currents. The CLI accepts:</p> <ul> <li><code>--pvd</code>: VTK time-series index produced by <code>motor_sim --vtk-series</code>.</li> <li><code>--scenario</code>: scenario JSON (required to extract timeline currents and bore   polygon).</li> <li><code>--save</code>: output path (MP4/GIF; binaries are uploaded as CI artefacts rather   than committed).</li> <li><code>--fps</code> and <code>--width</code>: tune playback speed and output resolution.</li> <li><code>--html</code>: emit an interactive HTML player (uses the same data as the MP4).</li> <li><code>--frame-png</code>: write a static render of the first frame (handy for docs or   quick inspection).</li> <li><code>--log-scale</code>: switch the |B| colour map to logarithmic scaling to emphasise   the field in low-magnitude regions.</li> </ul> <p>The animation is designed for the CI demo case and remains lightweight enough for larger offline runs.</p>"},{"location":"user-guide/machines/three-phase-stator/#notes","title":"Notes","text":"<ul> <li>The stator slots are modelled as polygonal <code>current_region</code> sources. Each   slot carries 60 turns with a 0.55 copper fill fraction so the deposited   ampere-turns match the intended winding pack without overdriving the bore   field. The timeline provides per-frame phase currents via the   <code>phase_currents</code> block.</li> <li>With the default 30 A peak phase currents the CI profile\u2019s bore probe reports   roughly 0.03\u202fT, so the rotating stator field remains visible when the PM   motor rotor is introduced.</li> <li>The bore-average sanity check (<code>python/check_three_phase_field.py</code>) unwraps   the bore field angle, verifies monotonic rotation, enforces an R\u00b2 &gt; 0.95 fit   against a straight line, and guards against magnitude collapse. The CI   workflow runs it automatically.</li> <li>Looking for a fully coupled permanent-magnet motor walkthrough? See   <code>docs/three_phase_pm_motor.md</code> for the rotor, circuit, and mechanical   co-simulation demo.</li> <li>Keep binary artefacts (MP4/VTI samples) out of git history. The CI workflow   uploads a small bundle with the demo VTK frame, bore CSV, and animation.</li> </ul> <p>Open in GUI</p>"},{"location":"user-guide/visualization/comparison-sor-vs-cg/","title":"SOR vs CG Visual Comparison","text":"<p>These artefacts highlight the difference between the historical SOR solver and the modern preconditioned CG backend.</p> <p></p> <p>CG reaches the target tolerance in roughly an order of magnitude fewer iterations on the iron-ring plus magnet scenario. Both runs use identical tolerances and grids.</p>"},{"location":"user-guide/visualization/comparison-sor-vs-cg/#field-evolution-snapshots","title":"Field evolution snapshots","text":"<p>The snapshots expose how CG removes low-frequency error earlier in the solve, yielding smooth fields while SOR continues to chew through residual ridges. Use these animations to explain solver choices to stakeholders or when preparing presentations.</p>"},{"location":"user-guide/visualization/comparison-sor-vs-cg/#warm-started-frame","title":"Warm-started frame","text":"<p>Warm starts keep consecutive timeline frames aligned, especially when combined with <code>--parallel-frames</code>. The second frame in the three-phase stator demo converges substantially faster than a cold start when warm-starting is enabled.</p>"},{"location":"user-guide/visualization/overview/","title":"Field Visualisation Options","text":"<p>The <code>python/visualize_scenario_field.py</code> helper renders solver field maps with a number of switches that mirror the \"Visualization Upgrades\" milestone from the roadmap.</p>"},{"location":"user-guide/visualization/overview/#command-line-summary","title":"Command-line summary","text":"<pre><code>python3 python/visualize_scenario_field.py \\\n  --scenario inputs/two_wire_cancel.json \\\n  --field-map outputs/two_wire_field_map.csv \\\n  --draw-boundaries \\\n  --streamlines \\\n  --overlay-analytic interface \\\n  --vector-mode log \\\n  --vector-log-floor 1e-6 \\\n  --color-scale log \\\n  --log-floor 1e-6\n</code></pre> <p>Key options:</p> <ul> <li><code>--color-scale {linear,log}</code> toggles between a linear palette and logarithmic   magnitude scaling. Pair with <code>--log-floor</code> to bound the minimum |B| value.</li> <li><code>--draw-boundaries</code> outlines material and magnet regions extracted from the   scenario JSON so discontinuities are easy to spot.</li> <li><code>--outline-vtp PATH</code> overlays solver-generated geometry outlines (domain,   rotor assemblies, magnets, wires). When supplied, the helper automatically   searches for the neighbouring <code>_labels.csv</code> metadata file so loop/group names   can be joined in ParaView.</li> <li><code>--streamlines</code> overlays streamlines traced from the field grid.</li> <li><code>--vector-mode {linear,log,off}</code> controls the quiver arrows. The <code>log</code> mode   compresses dynamic range using a log-normalised magnitude, while <code>off</code>   disables the overlay entirely. <code>--vector-log-floor</code> mirrors <code>--log-floor</code> for   the quiver transform.</li> <li><code>--overlay-analytic interface</code> draws contour lines for the planar permeability   interface analytic reference when available. Additional overlays can be added   under the same flag in the future.</li> <li><code>--save PATH</code> writes the rendered figure to disk; otherwise the viewer window   opens interactively.</li> </ul>"},{"location":"user-guide/visualization/overview/#ci-integration","title":"CI integration","text":"<p><code>scripts/run_ci_checks.sh</code> exercises these switches for the canonical demo scenarios so GitHub Actions artifacts include the enhanced renders. The iron ring and magnet strip plots use <code>--color-scale log</code> together with <code>--vector-mode log</code> to improve readability when the dynamic range spans several orders of magnitude, and the rotor ripple frames feed their per-frame <code>_outlines.vtp</code> files back into the renderer via <code>--outline-vtp</code> so the rotating rotor geometry is visible in the PNGs.</p>"},{"location":"user-guide/visualization/overview/#rotor-geometry-animations","title":"Rotor geometry animations","text":"<p>The new <code>python/generate_rotor_animation.py</code> helper renders rotor/stator motion using the geometry declared in a scenario JSON. It consumes the mechanical trace CSV (time, angle, speed) emitted by <code>motor_sim</code> and, when available, the circuit trace CSV (<code>circuit_trace</code> output) so stator slots can be coloured by their ampere-turns. Example invocation:</p> <pre><code>python3 python/generate_rotor_animation.py \\\n  --scenario inputs/dc_motor_spinup_ci.json \\\n  --rotor dc_rotor \\\n  --mechanical outputs/dc_motor_mechanical.csv \\\n  --circuit-trace outputs/dc_motor_currents.csv \\\n  --gif ci_artifacts/dc_motor_rotor.gif \\\n  --frame-png ci_artifacts/dc_motor_rotor.png\n</code></pre> <p>If a circuit trace is not supplied the script falls back to the timeline <code>phase_currents</code> data embedded in the scenario (useful for synchronous demos that prescribe the waveforms). When neither source is available the slots are rendered with neutral colours, still illustrating the rotor\u2019s motion. The CLI supports frame limiting (<code>--max-frames</code>), alternate figure sizes, and PNG-only exports for quick smoke tests. CI runs this helper for the PM, induction, and DC motor demos so the uploaded artefacts include geometry-focused animations in addition to the full-field ParaView series.</p>"},{"location":"user-guide/visualization/overview/#paraview-overlays","title":"ParaView overlays","text":"<p>When loading solver outputs directly in ParaView, open both the <code>.vti</code> field map and its <code>*_outlines.vtp</code> companion. The outline file carries cell data for the <code>kind</code> category and a <code>loop_index</code>, while the neighbouring <code>*_outlines_labels.csv</code> file provides the index-to-label mapping along with any rotor/stator group annotations. Join the CSV in the Spreadsheet view or an external tool to colour or filter geometry independently of the field. Select the <code>B</code> or <code>H</code> vector arrays for glyphs or streamlines\u2014the data are already packaged as three-component vectors, so no calculator filters are required.</p> <p>Open in GUI</p>"},{"location":"user-guide/visualization/vtk-output/","title":"VTK Field Map Exports","text":"<p>The solver can emit full-field snapshots in VTK XML ImageData (<code>.vti</code>) format. VTK files provide:</p> <ul> <li>Compact binary storage suitable for large grids</li> <li>Direct visualisation in ParaView, VisIt, and similar tools</li> <li>Straightforward ingestion from Python via <code>vtk</code> and NumPy</li> </ul>"},{"location":"user-guide/visualization/vtk-output/#requesting-a-vtk-export","title":"Requesting a VTK export","text":"<p>Add a field-map output with <code>\"format\": \"vti\"</code> to a scenario JSON (or use <code>scenario_api.FieldMapOutput(format=\"vti\")</code>). When no explicit <code>path</code> is provided the ingestor writes to <code>outputs/&lt;id&gt;.vti</code>.</p> <pre><code>{\n  \"type\": \"field_map\",\n  \"id\": \"field_frame_000\",\n  \"quantity\": \"B\",\n  \"format\": \"vti\"\n}\n</code></pre> <p>Each VTK file stores cell-centred datasets named <code>B</code>, <code>Bx</code>, <code>By</code>, <code>|B|</code>, <code>H</code>, <code>Hx</code>, <code>Hy</code>, <code>|H|</code>, and <code>energy_density</code>. The <code>B</code> and <code>H</code> arrays are true vector fields (three components with a zero Z entry) so ParaView can render streamlines or glyphs without manual component selection. Scalar components are still available for quick inspection. Values are computed by averaging the four surrounding nodes before evaluating magnitudes and the energy density (\\(\\tfrac{1}{2}\\,\\mathbf{B}\\cdot\\mathbf{H}\\)).</p> <p>Alongside each <code>.vti</code> export the solver writes a <code>*_outlines.vtp</code> PolyData companion that contains the domain rectangle, material polygons, magnet outlines, and wire circles as closed polylines. ParaView can load the outline file as a second source and overlay it on the field map using a <code>Glyph</code>/<code>Tube</code> filter or simple line rendering. Cell data include a <code>kind</code> integer (<code>0=domain</code>, <code>1=material</code>, <code>2=magnet</code>, <code>3=wire</code>) and a <code>loop_index</code> identifier. A CSV with the same stem and <code>_labels.csv</code> suffix records the mapping from <code>loop_index</code> to human-readable labels and a <code>group</code> column used for rotor assemblies or other geometry groupings, making it easy to drive ParaView filters or colour maps via simple joins in the Spreadsheet view or external tooling.</p>"},{"location":"user-guide/visualization/vtk-output/#verifying-the-output","title":"Verifying the output","text":"<p>Use the helper script to confirm ParaView-readable structure and non-empty arrays (including the combined vector fields):</p> <pre><code>python python/verify_vtk.py outputs/field_frame_000.vti\n</code></pre> <p>On success the script prints <code>VTK verification: PASSED</code>. The implementation uses raw-appended binary payloads with 64-bit length headers, so files remain small for large grids while keeping the XML metadata legible.</p> <p>Open in GUI</p>"}]}